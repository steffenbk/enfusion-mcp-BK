[
  {
    "title": "Event System",
    "source": "enfusion",
    "content": "Description\nThe Event System consists of two main components: an event provider and an event receiver. Events flow in one direction — from the provider to the receiver.\nTo ensure proper usage and maintainable design, only specific classes are allowed to act as providers or receivers. These restrictions offer better control over the system and help prevent misuse. Compatibility and connections are validated during compile-time.\n\nEvent Provider\n\nMust inherit from the EventProvider base class.\nTo maintain clarity and simplicity, only selected native classes are allowed to inherit from EventProvider. This may vary between projects. For scripting scenarios, the class is sealed to disallow custom script-based providers. Valid providers typically include:\nWorldSystem\nWorldController\n\n\nContains methods marked with [EventAttribute], representing the events it can broadcast.\n\n\nAPI\n\nConnectEvent \n Establishes a connection between an event on the provider and a callback method on the receiver.\nThe provider may restrict which receiver types are accepted.\nReceiver callbacks must have a compatible signature with the event.\n\n\nDisconnectEvent \n Removes a specific event connection between a provider and a receiver.\nAlternatively, can be used to remove all connections between a specific provider and receiver.\n\n\nThrowEvent \n Invokes all registered callbacks for an event.\nCallbacks are executed in the order they were connected.\nArguments must match the event declaration.\n\n\n\nRemarksAll connections use weak pointers internally. However, it is strongly recommended to explicitly disconnect events when a receiver is being destroyed to avoid orphaned connections.\n\nExample\nclass TestWorldSystem: WorldSystem\n{\n    void Helllo();\n    \n    [EventAttribute()]\n    void SomeEventA(TestWorldSystem sender, int param1, string param2);\n    \n    [EventAttribute()]\n    void SomeEventB(string msg);\n    \n    void Process()\n    {\n        ThrowEvent(SomeEventA, this, 45, \"hello\");\n        ThrowEvent(SomeEventB, \"wololoo\");\n    }\n}\n\nEvent Receiver\n\nTechnically, any managed object may act as a receiver. \n However, each provider can define which receiver types are permitted.\nFor example, WorldSystem and WorldController accept:\nGenericEntity\nGenericComponent\n\n\n\n\nReceiver methods must be marked with [ReceiverAttribute]. \n These methods can be connected to or disconnected from provider events.\n\n\nExample\nclass SomeControllerClass: ScriptComponentClass\n{\n}\n \nclass SomeController: ScriptComponent\n{\n    TestWorldSystem m_system;\n    \n    \n    [ReceiverAttribute()]\n    void OnSomeEventA1(TestWorldSystem sender, int param1, string param2)\n    {\n        Print(\"OnSomeEventA1\");\n    }\n    \n    [ReceiverAttribute()]\n    void OnSomeEventA2(TestWorldSystem sender, int param1, string param2)\n    {\n        Print(\"OnSomeEventA2\");\n    }\n        \n    [ReceiverAttribute()]\n    void OnSomeEventB(string msg)\n    {\n        Print(\"OnSomeEventB\");\n    }\n    \n    void Init(TestWorldSystem system)\n    {\n        m_system = system;\n        TestWorldSystem.ConnectEvent(system.SomeEventA, this.OnSomeEventA1);\n        TestWorldSystem.ConnectEvent(system.SomeEventA, this.OnSomeEventA2);\n        TestWorldSystem.ConnectEvent(system.SomeEventB, this.OnSomeEventB);\n    }\n    \n    void ~SomeController()\n    {\n        EventProvider.DisconnectEvents(m_system, this);\n    }\n}",
    "filename": "Page_EventSystem.html"
  },
  {
    "title": "Workbench NET API",
    "source": "enfusion",
    "content": "About\nEnfusion Workbench NET API provide network protocol for communication between Workbench and external tools. External tool connects to the Workbench NET API endpoint using TCP/IP socket and sends / recieves data according to the Workbench protocol. Sending and receiving integer and string (UTF-8 encoded) values are supported and each data transaction requires a new TCP/IP connection. Integer is represented by 4-byte little endian and string is in the Pascal-style string format (first 4-byte integer information repsesents the string length).\nCommunication is always initiated from the client side. When all the data are passed (based on the protocol) the Workbench sends a response.\n\nProtocol\nThe protocol is proprietary and very simple.\n\nRequest\nWhole message consist of four parts as visualized on the following diagram.\n┌──────────────┬─────────────────┬──────────────────┬──────────────────────────────────┐\n│ Protocol Ver.│   Client ID     │   Content Type   │       Payload                    │\n│              │                 │                  │                                  │\n│  (Integer)   │   (String)      │    (String)      │       (String)                   │\n└──────────────┴─────────────────┴──────────────────┴──────────────────────────────────┘\nStringstring String(string s)Helper for passing string expression to functions with void parameter.Definition Types.c:14\n\nProtocol Ver. - integer values of the protocol version, currently only version 1 is supported.\nClient ID - string representation of the client making the request, for example PythonClient.\nContent Type - the format of the payload, currently only JsonRPC is supported.\nPayload - JSON message encoded as UTF-8 string.\n\n\nPayload format\nThe JsonRPC payload format is a JSON encoded as a string, defining what API endpoint to call by its name (APIFunc) as well as parameter names and their respective values.\n{\n    \"APIFunc\": \"Enforce Script Class implementing NetApiHandler or built-in function name\",\n    \"PARAM1\" : \"Value1\",\n    \"PARAM2\" : 0,\n    \"PARAM3\": {\n        \"A\": true,\n        \"B\": \"false\"\n  },\n}\nFollowing list contains all the built-in function you can use in the APIFunc.\n\nOpenResource\nrequired parameters for input: {\n    \"APIFunc\": \"OpenResource\",\n    \"ResourceName\": \"string\", // name of a resource file to open in Workbench\n}\n\nresponse: {\n    \"Opened\": \"bool\", // result of the operation\n}\n\n\n\nBringModuleWindowToFront\nrequired parameters for input: {\n    \"APIFunc\": \"BringModuleWindowToFront\",\n    \"ModuleName\": \"string\", // name of a workbench module\n}\n\nresponse: {\n    // none\n}\n\n\n\nIsWorkbenchRunning\nrequired parameters for input: {\n    \"APIFunc\": \"IsWorkbenchRunning\",\n}\n\nresponse: {\n    \"IsRunning\": \"bool\", // is workbench running\n    \"ScriptsCompiled\": \"bool\", // are scripts compiled successfully\n}\n\n\n\nIsWorldEditorRunning\nrequired parameters for input: {\n    \"APIFunc\": \"IsWorldEditorRunning\",\n}\n\nresponse: {\n    \"IsRunning\": \"bool\", // is workbench running\n    \"ScriptsCompiled\": \"bool\", // are scripts compiled successfully\n}\n\n\n\nValidateScripts\nrequired parameters for input: {\n    \"APIFunc\": \"ValidateScripts\",\n    \"Configuration\": \"string\", // script configuration to validate (see project settings, e.g. WORKBENCH, PC, PLAYSTATION, XBOX...)\n}\n\nresponse: {\n  // array of errors\n  \"Errors\": [\n    {\n      \"error\": \"Incompatible parameter 'b'\", // text of error\n      \"file\": \"scripts/Game/game.c\", // file where error occurs\n      \"fileAbs\": \"F:\\\\DATA\\\\scripts\\\\Game\\\\game.c\", // optional, present just for scripts which are unpacked\n      \"addon\": \"MyAddon\", // optional, present just for scripts which are unpacked\n      \"line\": 147 // position in file where error occurs\n    }\n  ],\n  // array of warninigs\n  \"Warnings\": [\n    {\n      \"error\": \"Variable 'a' is not used\", // text of warning\n      \"file\": \"scripts/Game/game.c\", // file where warning occurs\n      \"fileAbs\": \"F:\\\\DATA\\\\scripts\\\\Game\\\\game.c\", // optional, present just for scripts which are unpacked\n      \"addon\": \"MyAddon\", // optional, present just for scripts which are unpacked\n      \"line\": 146 // position in file where warning occurs\n    }\n  ],\n  \"Success\": false\n}\n\n\n\n\n\nResponse\nMessage consists of two parts.\n┌──────────────┬────────────────────────────────────┐\n│ Error Code   │       Payload                      │\n│              │                                    │\n│  (String)    │       (String)                     │\n└──────────────┴────────────────────────────────────┘\n\nError Code - string representation of the error code.\nPayload - JSON message encoded as UTF-8 string.\n\n\nPayload format\nThe JsonRPC payload format is a JSON encoded as a string, the format is specific for each APIFunc which was called in the request.\n\nCustom endpoint\nMost of the time you will want or need to implement your own logic of what should be done and return from the Workbench to the caller. In order to do so, you need to implement few things in the Enforce Script and have such script running in a live instance of the Workbench.\n\nImplement your own API endpoint by extending NetApiHandler.\nDefine your own request (JsonRPC format) by extending JsonApiStruct.\nDefine your own response by extending JsonApiStruct.\n\n\nExample script\nclass ExampleRequest : JsonApiStruct\n{\n    string input;\n \n    void ExampleRequest()\n    {\n        RegV(\"input\");\n    }\n}\n \nclass ExampleResponse : JsonApiStruct\n{\n    string output;\n    \n    void ExampleResponse()\n    {\n        RegV(\"output\");\n    }\n}\n \n// Class that is being called\nclass ExampleCall : NetApiHandler\n{\n    override JsonApiStruct GetRequest()\n    {\n        return new ExampleRequest();\n    }\n \n    override JsonApiStruct GetResponse(JsonApiStruct request)\n    {\n        ExampleRequest req = ExampleRequest.Cast(request);\n        ExampleResponse response = new ExampleResponse();\n        \n        Print(req.input);\n        response.output = \"Hello from Workbench\";\n \n        return response;\n    }\n    \n}",
    "filename": "Page_NetApi.html"
  },
  {
    "title": "Replicating entities, components and hierarchies",
    "source": "enfusion",
    "content": "While it is possible to use RplNode for replication of just about anything (see RplNode for more on this), in most cases, people deal with entities and components.\nRplComponent is component that provides glue between replication and system of entities and components. It does this by creating RplNode, inserting entities and components into RplNode, then registering RplNode in replication. Only entities or components whose replication layout is not empty (contains at least one replicated property, RPC, or replication callback) will be inserted. Everything else will be ignored by replication and cannot be referenced through it (eg. using RplId).\nBase implementation of RplComponent is in gamelib::BaseRplComponent, however each game typically provides its own implementation derived from this base with game-specific changes. It is recommended to name this game-specific implementation RplComponent to avoid confusion, but you should consult game documentation to find out what the name is, as well as what (if any) differences there are compared to default behavior described in this document.\nRplComponents impose some limitations on prefab structure and manipulation of entities spawned as part of hierarchy. Because of this, it is recommended that also people who don't normally deal with replication and only create prefabs and manage prefab structure and inheritance, have at least basic understanding of rules and examples described in this document.\n\nCreation of RplNode\nSimply put, RplComponent during its EOnInit will collect replicated entities and components (those that have RPCs or replicated properties) and add them as items into its RplNode. Gathering process first considers entity to which RplComponent is attached, and its components. Then it checks whether RplComponent has Recursive property enabled. If it is not enabled, process ends. If it is enabled, it recursively processes child entities in same manner. Recursion does not enter entities which have their own RplComponent.\nFollowing is pseudo-code version of the algorithm: void GatherItems(entity, rplComponent)\n{\n    if (entity.IsReplicated())\n        rplComponent.InsertItem(entity);\n \n    foreach (component in entity.components)\n    {\n        if (component.IsReplicated())\n            rplComponent.InsertItem(component);\n    }\n \n    if (rplComponent.recursive)\n    {\n        foreach (child in entity.children)\n        {\n            if (!child.HasComponent(RplComponent))\n                GatherItems(child, rplComponent);\n        }\n    }\n}\n \nGatherItems(rplComponent.entity, rplComponent);\nRplComponentDefinition RplComponent.c:18\nWhile above process may appear simple at first, it affects quite a lot and it is important that people working with replication intuitively understand how items are grouped into nodes, as that limits what they can and cannot do at runtime. To make all of this easier to understand, it is best show it on some examples. Let's first look at a simple entity with some components:\n\n<p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p>\nHere we have an entity A with 4 components: r, a, b and c. Component r is RplComponent, which will create the RplNode instance and fill it with replicated items. Components b and c are not replicated (they do not have any RPCs or replicated state) and so they are not part of created RplNode. RplNode in replication hierarchy will then contain 3 items: r, A and a. Notice how RplComponent is first item in the node, which means it is the head (see RplNode for details). Because this example only has one entity, results of simple (non-recursive) and recursive gathering look the same. Differences start to show up with entity hierarchies.\n\nHierarchies\nLet's first take a look at some simple entity hierarchy and how it will translate into node:\n\n<p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p>\nOnce again, first item in the node is RplComponent r1. We then collect replicated items from the hierarchy and insert them into the node as well, while ignoring items which are not replicated. Important to notice is that entity hierarchy itself is not reflected in the node structure. Node is, after all, just a flat list of items. Pay attention to differences between results of simple and recursive gathering. In simple version, entities B and C are completely ignored, and replication knows nothing about them (thus RPCs, replicated properties and other replication features will not work). In recursive version, both of them were considered during gathering process. Notice also that in recursive version, even though entity C is not replicated, its replicated component e was still added to the node.\nHierarchies with just one RplComponent on root entity will always produce one node consisting of flattened list of replicated items. Things become more interesting when there are are multiple RplComponents present in the hierarchy:\n\n<p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p>\nBy adding component r2 to entity B, we have created a new node r2, which is child of node r1 (previously node r). This allows us to detach entity B (node r2) from entity A (node r1) at runtime. What we can and cannot do with entity C now differs between simple and recursive version. In simple version, replication does not put any constraints on what we can do with C. However, in recursive version, entity C must always remain child of entity A, because they are part of the same node that cannot be modified after it has been inserted into replication.\nOne more example that demonstrates a bit more complicated hierarchy. Notice how hierarchy of entities and hierarchy of nodes can look quite different:\n\n<p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p>\nRplComponent sets up and maintains replication hierarchy by listening for changes in entity hierarchy and performing similar operations on node hierarchy in replication. This behavior is controlled using RplComponent property \"Parent Node From Parent Entity\", which is currently turned on by default. When turned off, replication node managed by this component will not have its parent replication node modified to match node of new parent entity. We can demonstrate this on above example. If we were to turn off \"Parent Node from Parent Entity\" on RplComponent r2, we would create two independent replication hierarchies:\n\n<p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p>\nThis can be a powerful tool when optimizing streaming. Replication hierarchy is streamed all at once and, for larger hierarchies, this can lead to very large messages and expensive instantiation on clients. It may also lead to streaming unnecessary data to clients. Large buildings may have objects placed inside which are unlikely to become visible for particular client due to distance or obstacles, but if those objects are children of this building (in replication hierarchy), they will always be streamed together with the building itself. By turning off \"Parent Node From Parent Entity\" on these objects, scheduler can control them independently from building itself. As a consequence, one must keep in mind that presence of parent entity on client does not necessarily imply presence of children that turn this setting off.\n\nPrefabs\nRemember that you must not add or remove items from node after it has been inserted into replication system, but you can modify hierarchy of nodes themselves. This means that entities with RplComponent are movable parts of the hierarchy and can be removed or added as the game progresses. When new player joins an already running game (\"join-in-progress\", or JIP for short), we need to communicate these changes. To keep traffic low, server sends only limited information:\nWhich entity from which prefab to spawn to recreate each node.\nHow to connect these nodes into hierarchy.\n\n\nProblematic situations\n\nPrefab root does not have RplComponent\nOne problem that can arise is prefab where root entity does not have RplComponent:\n\n<p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p>\nAs you can see, replication system does not know anything about entity A and its components, as they are not part of the RplNode. This causes problems when spawning this prefab at runtime (or during JIP), because we can't associate RplNode with resource GUID of the prefab from which it came.\nThere are two possible solutions in this case:\nMove RplComponent from entity B to entity A.\nAdd RplComponent to entity A, in addition to entity B. This is required if you need to change who is parent of entity B at runtime.\n\n\nParent entity is not RplNode\nYou should be careful when intermediate entities between two entities with RplComponent do not form nodes themselves. An example case of this problem:\n\n<p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p>\nThis might look like it should work at first, and in many cases it will. Problems will arise when this hierarchy is streamed to the client as part of JIP. Replication can only reconstruct the hierarchy of nodes, but that does not have information about entity B being child of entity A, so the hierarchy will be set up differently between client and server, leading to desync. While on its own this is not an issue for replication, it may cause problems in game code. For example, sending position relative to parent from server to client will cause client to interpret that position against different parent, giving wrong results.\nMore insidious case of this would arise if entity B was not replicated (no replicated state or RPCs) or if simple gathering of items was used (instead of recursive), in which case, it wouldn't even exist in the RplNode r1. It wouldn't have RplId assigned in which case user code can't correct the hierarchy either, unless it implements its own mechanism for addressing these non-replicated entities.\nPossible solutions are:\nAdd RplComponent to entity B, making it a node itself and thus getting replication hierarchy closer to entity hierarchy.\nMake entity C direct child of entity A.",
    "filename": "Page_Replication_EntitiesAndComponents.html"
  },
  {
    "title": "Loadtime and Runtime",
    "source": "enfusion",
    "content": "What are these about\nThere are two main replication game states which replication distinguishes and which affect some characteristics of replicated items: loadtime state and runtime state. Items inserted into replication while game is loading (ie. at loadtime) are treated as loadtime items, while those inserted once the game is running (ie. at runtime) are treated as runtime items when inserted on server, or local items when inserted on client (as they only exist locally).\nAs always, for simplicity this page will use \"items\" to refer to both entities and components (and anything else that might be replicated).\n\nLoadtime items\nLoadtime items are generally entity instances placed in world. These are objects that shouldn't be moved around too much (though some degree of movement is allowed) and usually need to be visible from greater distances. Typical examples are buildings or street signs. Main things to keep in mind:\nThey do not require prefab for spawning.\nTheir insertion must be deterministic on server and clients. Server relies on clients to have the same initial world state after the map has been loaded. It can then replicate changes from this initial state as they become relevant for a given client, reducing overall traffic (by sending only changes) and spreading the load over time. Client will still be able to see things in the distance, even though their state has not been perfectly synchronized.\nReplication validates that initial world state matches. That is, RplId and type information of each loadtime item is the same on client as was on server initially. When a mismatch is detected, \"inconsistent item table\" error will appear in log and client will be disconnected with JIP_ERROR.\n\n\nThey may be out-of-sync with server for a long time (possibly throughout whole play session). Replication scheduler running on server decides when to stream their current state to each client. When this decision is based on proximity, clients will only get current state streamed in when they get \"close enough\" for these changes to be relevant. Because of the world size, this may take a while or never happen at all.\nThe only exception is complete removal of these items on server. In that case, removal will be replicated to clients unconditionally.\n\n\nAs long as authority exists on server, proxy exists on client.\nStreaming in synchronizes state of proxy with authority. Once streamed in, proxy starts receiving state updates and it can send and receive RPCs.\n\n\n\nWarningStreaming out loadtime items while authority exists on server is currently considered undefined behavior. It should be avoided!\n\nRuntime items\nRuntime items generally come from some game system that creates them during session. They can move around the map freely and they are usually not visible from far away. Typical examples are vehicles, player characters, collectible items. Main things to keep in mind:\nThey require prefab for spawning.\nThey may only be inserted on server. This is the authority.\nProxy may or may not exist on a client.\nStreaming in creates a proxy.\nStreaming out destroys this proxy.\nWhile proxy exists, it receives state updates and it can send and receive RPCs.\n\n\n\n\nLocal items\nLocal items are items inserted on client during session. They can be used for locally predicted effects of player actions, such as firing from rocket launcher immediately creating a flying rocket on client who fired it, instead of waiting for server-side rocket to be streamed to this client. Main things to keep in mind:\nThey do not require prefab for spawning.\nThey may only be inserted on client. This is the authority.\nThere are no proxies on server or other clients.\n\nNoteIt is common to run same code on server and clients. This can sometimes lead to unintended insertion of local items on clients. In order to prevent accidents, Arma Reforger modifies prefab spawning in a way that (by default) only allows spawning prefabs on server.\n\nReplication state override\nReplication state override (represented by RplStateOverride enum and configured using \"Rpl State Override\" property) is a property of RplComponent that allows modifying the behavior of spawning and insertion process to behave as-if insertion of node hierarchy happened in specified state. Currently supported values are:\nNone\nState for this node and its descendants at the time of insertion is inherited from parent node (on root of node hierarchy, it is current replication game state).\n\n\nRuntime\nState for this node and its descendants at the time of insertion is considered to be runtime.\n\n\n\nIn other words, as of right now it is only possible to change from loadtime to runtime state. This allows creation of complex prefabs that combine together both loadtime items and runtime items. As an example we can use prefab of a building with doors and windows (typical loadtime items) as well as food and weapons (typical runtime items) that player can pick up and carry around. To make this work, we set items meant to be carried around to use Runtime override. This will ensure that even if they were inserted while loading the map, they will be subject to rules for runtime items, rather than loadtime items. However, we have to make sure that none of the items meant to be loadtime items are descendants of those with Runtime override, otherwise the override will apply to them as well.\nNotice also how state override applies to node and its descendants at the time of insertion. With entities and components, child entities spawned during initialization must be attached to parent as part of spawning process.\nWarningA common mistake is to spawn an entity first and then attach it as child of entity that spawned it. However, this results in spawned entity being inserted separately from parent. If this happens at loadtime and parent entity had state overridden to be runtime, child entity will not inherit state override (because it was not child at the time of insertion). It will instead be inserted as loadtime. Runtime entity spawning loadtime entity is currently considered undefined behavior because it violates requirement for deterministic insertion on server and client (runtime entities are not spawned on client, so they can't spawn loadtime children on client either) and should be avoided!\nOne could argue that overriding state should not be necessary, because correctly created map and systems for spawning dynamic objects like player and non-player characters, vehicles and items, will make sure that everything happens in correct game state. While that may be true, there may still be situations where these state overrides are useful:\nSimpler creation of map for testing.\nOne doesn't have to configure complicated loot system just to have a car for testing in the map. Well made car prefab can just be dropped in the map and messed around with as if it were spawned by some loot system.\n\n\nSupport for less dynamic map design.\nGames with relatively static level structure and carefully placed collectibles have no need for dynamic loot systems and all loot would be placed manually. Join-in-progress for coop mode in such games should just work when these items are correctly configured.\n\n\nGreater resilience against mistakes.\nWe don't live in ideal world and mistakes happen. Sometimes, prefabs may be used in the map directly instead of being left up to dynamic spawning system. While that may seem like a small issue for designers who would be performing clean sweep later in the development cycle, it can potentially lead to various undefined behaviors once players interact with these items in multiplayer, causing crashes and stability problems which are much more serious (and harder to track down). Correctly configured prefab can stay misplaced without causing any issues.",
    "filename": "Page_Replication_LoadtimeAndRuntime.html"
  },
  {
    "title": "Replication overview",
    "source": "enfusion",
    "content": "Introduction\nGameplay networking in the Enfusion engine is based client-server architecture model. In this model, server is authoritative over game simulation and acts as the source of truth. Each client only communicates with the server, never with other clients, and server decides what each client knows about and what it can do at any given moment.\nReplication is a system for facilitating and simplifying implementation of game world and simulation shared by multiple players over network. It introduces high level concepts and mechanisms for handling issues inherent in multiplayer games, such as:\nunreliability of network communication, where packets may be lost or arrive out of order\nlimited amount of bandwidth available for network communication\nmalicious players using cheats to gain unfair advantage over others\n\nIt is important to keep in mind that while replication provides tools, it is up to users (programmers and scripters) to make sure they are used appropriately. Understanding and accounting for the impact of replication on architecture of game objects (entities and components) as well as gameplay systems early in the project development is crucial. Some design decisions may be hard or impossible to change later in the development (often due to time constraints and many other things being built on top of them) and so it is important that they are efficiently networked and tested from the very beginning.\n\nThe Big Picture\nLet us first introduce the terminology and how all things work together, before going into specifics. This section will only give rough description of how things work in the most common situations and leave important details and specifics for later.\nReplication runs in one of two modes: server or client. Server hosts replication session and clients connect to this session. There is always exactly one server and there can be any number of players (up to max player limit). Server is the only one who knows about everything and if it disappears, session ends and clients are disconnected. It is not possible for a client to take over when server has disappeared.\nServer can be hosted in one of two modes: listen server and dedicated server. Listen server is server hosted by one of the players. It accepts inputs (keyboard, mouse, controller, etc.) from hosting player directly and provides audio-visual output to hosting player. Dedicated server does not have a way to accept inputs or provide audio-visual output and it only allows players to connect remotely.\nThe smallest unit that replication works with, is an item. Only items created on server will be shared with clients. Item created on a client will only exist on this client and nobody else can see it. An item can by many things, but the most common ones are entities and components. Not all entities and components are items, though. For an entity or component to be registered in replication as an item, it must have at least one of the following:\nreplicated properties\nfunctions callable using remote procedure calls (RPCs)\nreplication callbacks\n\nMultiple items are grouped together into a node, which is then registered in replication. Once a node has been registered, list of items in it cannot be modified (items cannot be added, removed or destroyed) until the node is removed from replication. The most common node for entities and components is RplComponent.\nEach node can have a parent node and multiple child nodes, forming a node hierarchy. Node hierarchies can be changed dynamically, after nodes were registered in replication. This can be used for dynamically modified entity hierarchies, such as player character entering into a car and driving around in it.\nNode hierarchies on clients may not always be present or synced up with server since a world was loaded, and process managing their presence is called streaming. Process of node hierarchy being created or synced up on client is called streaming in. The opposite process, when node hierarchy is being removed from client, is called streaming out.\nStreaming on server is primarily governed by replication scheduler. Scheduler determines whether a node hierarchy is relevant for a client and orders it to be streamed in or out based on that. It also determines priority and frequency of replicating properties of an item, to make sure that available bandwidth is used where it matters the most. All of this depends heavily on the type of game, so scheduler is usually fine-tuned for every game to some extent. Most of the relevancy and prioritization is based on distance of an object in the game world from the player, so that closer objects are updated more often, while distant objects are updated less often or streamed out completely. However, there are also more abstract concepts in games (such faction-specific data), which require different rules for determining relevancy. Scheduler provides means for game to implement these custom rules as necessary.\n\nArchitecture implications\nBecause node hierarchy is the unit of streaming (in general, whole node hierarchy is either streamed in or out on a particular client), it is very important to take it into consideration when thinking about architecture of various systems. Specifically, we want to make sure that client gets some information only when it is really necessary.\nLet's say a player is part of a team that is spread out over the game world. We would like to implement a map UI that allows this player to see where in the world all of their teammates are right now. Positions of all team members are updated in real-time as they move around. This map is only visible when player opens it, it is not a minimap that is always present in the corner of the HUD.\nAn obvious approach would be to just use positions of characters of each team member and draw markers on the map corresponding to those positions. This may appear to work correctly at first, but as soon as one of the team members goes far enough and their character streams out, their marker on the map will also disappear.\nTo address that, one could set things up in scheduler so that team members are always relevant for each other. This way, no matter how far away they move from each other, they will always know where rest of their team members are. This addresses the problem with missing markers on the map and, for some games, this may be good enough. However, there are several problems with this approach:\nSingle character is far more than just its position. By making all of it relevant, we replicate also changes to its equipment, animations, and anything else that is necessary for a character in 3D scene. However, for distant characters we only need their 2D position on the map.\nWe only need this information when the map is open.\n\nIdeal solution decouples streaming of data needed for map display from data needed for animated character in 3D world. Because node hierarchy is streamed as a whole, this requirement forces us to replicate these things using independent node hierarchies. Character data will continue to have relevancy based on location in the world, so that their impact is reduced as they get further away. For map indicators, when player opens the map, client makes a request to the server, showing interest in data for map indicators. Server then makes map indicators relevant for this particular client, which begins replicating their state and changes. Server has to update these map indicators to reflect changes in positions of actual characters, but if none of the players have map open, these markers do not produce any network traffic and their CPU cost is minimal. Obviously, there are more improvements possible, such as quantizing marker positions, updating only when they are relevant for some client, etc. But the most important optimization, is separation of data that is only loosely related.\nThere are two ways to implement map markers in this case:\nImplement each marker as a separate node.\nGroup multiple markers in a single node.\n\nWhich of these two approaches is better depends on a particular problem being solved. In general, first approach is recommended. Second one may be easier to implement at first, but it may also be harder to optimize or adjust to new requirements when design changes.\n\nFundamentals\nNow that we have described how things work overall, let us take a look at a few examples of using replication in code. We will start by looking at a simple animation that does not use replication at all. Next we will modify this animation to use replication. Finally, we will implement a more complicated system that allows multiple players to interact with it.\nNoteThese examples, as well as the rest of documentation, assume reader is already familiar with entities, components and world editor. Specifically, one should already know how to:\ncreate an entity with components of specific types\nset a property of an entity or component to particular value\ncreate an entity prefab\norganize entities in a hierarchy both in prefab and in code\nmodify an existing world or create new one for testing\n\n\nTo make things easier to visualize, all examples will use following entity to draw a debug sphere in the world, with sphere color selected using an index:\nclass RplExampleDebugShapeClass: GenericEntityClass {}\nRplExampleDebugShapeClass g_RplExampleDebugShapeClassInst;\n \nclass RplExampleDebugShape : GenericEntity\n{\n    static const int COLOR_COUNT = 4;\n    static const int COLORS[] = {\n        Color.BLACK,\n        Color.RED,\n        Color.GREEN,\n        Color.BLUE,\n    };\n \n    private int m_Color;\n \n    void RplExampleDebugShape(IEntitySource src, IEntity parent)\n    {\n        this.SetEventMask(EntityEvent.FRAME);\n    }\n \n    override void EOnFrame(IEntity owner, float timeSlice)\n    {\n        vector worldTransform[4];\n        this.GetWorldTransform(worldTransform);\n        Shape.CreateSphere(m_Color, ShapeFlags.ONCE, worldTransform[3], 0.5);\n    }\n \n    bool SetColorByIdx(int colorIdx)\n    {\n        if (colorIdx < 0 || colorIdx >= COLOR_COUNT)\n            return false;\n \n        m_Color = COLORS[colorIdx];\n        return true;\n    }\n}\nNoteAll classes in these examples (including entities and components) are not available by default. To try these examples yourself, you need to add them to some script file (new or existing one) and \"Compile and Reload Scripts\" in Script Editor, so that entities and components from the code become available.\n\nExample animation without replication\nOur first example will be simple animation that changes color of our shape over time. We will switch to next color every couple of seconds and, after reaching last color, we will wrap around and continue from the first one. All of the example code is implemented in single component:\nclass RplExample1ComponentColorAnimClass : ScriptComponentClass { }\nRplExample1ComponentColorAnimClass g_RplExample1ComponentColorAnimClass;\n \nclass RplExample1ComponentColorAnim : ScriptComponent\n{\n    // Constant specifying how often (in seconds) to change the color index. For\n    // example, setting this to 5 will change the color index every 5 seconds.\n    private static const float COLOR_CHANGE_PERIOD_S = 5.0;\n \n    // Helper variable for accumulating time (in seconds) every frame and to calculate\n    // color index changes.\n    private float m_TimeAccumulator_s;\n \n    // Color index currently used for drawing the sphere.\n    private int m_ColorIdx;\n \n    override void OnPostInit(IEntity owner)\n    {\n        // We check whether this component is attached to entity of correct type and\n        // report a problem if not. Once this test passes during initialization, we\n        // do not need to worry about owner entity being wrong type anymore.\n        auto shapeEnt = RplExampleDebugShape.Cast(owner);\n        if (!shapeEnt)\n        {\n            Print(\"This example requires that the entity is of type `RplExampleDebugShape`.\", LogLevel.WARNING);\n            return;\n        }\n \n        // We initialize shape entity to correct color.\n        shapeEnt.SetColorByIdx(m_ColorIdx);\n \n        // We subscribe to \"frame\" events, so that we can run our logic in `EOnFrame`\n        // event handler.\n        SetEventMask(owner, EntityEvent.FRAME);\n    }\n \n    override void EOnFrame(IEntity owner, float timeSlice)\n    {\n        // We calculate change of color index based on time (and configured color\n        // change period), then apply the change in color.\n        int colorIdxDelta = CalculateColorIdxDelta(timeSlice);\n        ApplyColorIdxDelta(owner, colorIdxDelta);\n    }\n \n    private int CalculateColorIdxDelta(float timeSlice)\n    {\n        // We first accumulate time and then calculate how many color change periods\n        // have occurred, giving us number of colors we've cycled through.\n        m_TimeAccumulator_s += timeSlice;\n        int colorIdxDelta = m_TimeAccumulator_s / COLOR_CHANGE_PERIOD_S;\n \n        // We remove full periods from the accumulator, only carrying over how much\n        // time from current period has elapsed.\n        m_TimeAccumulator_s -= colorIdxDelta * COLOR_CHANGE_PERIOD_S;\n \n        return colorIdxDelta;\n    }\n \n    private void ApplyColorIdxDelta(IEntity owner, int colorIdxDelta)\n    {\n        // If there is no change to color index, we do nothing.\n        if (colorIdxDelta == 0)\n            return;\n \n        // We calculate new color index.\n        int newColorIdx = (m_ColorIdx + colorIdxDelta) % RplExampleDebugShape.COLOR_COUNT;\n \n        // We check also new color index, since shorter periods and lower frame-rate\n        // may result in new and old color index values being the same.\n        if (newColorIdx == m_ColorIdx)\n            return;\n \n        // Now we can update the color index ...\n        m_ColorIdx = newColorIdx;\n \n        // ... and set new color based on new color index value.\n        RplExampleDebugShape.Cast(owner).SetColorByIdx(m_ColorIdx);\n    }\n}\nTo see it in action, we need to place RplExampleDebugShape entity in a world and attach RplExample1ComponentColorAnim component to it. After switching to play mode, you should see a sphere at the position where you placed your entity. This sphere will change color every 5 seconds, cycling through black, red, green and blue, before starting from the first color again. If for some reason you do not see this, then you should determine what is the problem before moving on.\nIf you were to try this in a multiplayer session (using Peer tool plugin), you will notice that the color of our sphere changes at different time for client and server. Furthermore, depending on multiple factors, color of the sphere is also different between client and server. Why is that? Let's break down what is happening in more detail.\nThe moment our entity is created marks the beginning of our color animation, which then advances every frame based on elapsed time. For our animation to be the same on both client and server, we need to ensure that they both create the entity at the same time, so that starting point of the animation matches. Unfortunately, this is almost never the case, so we usually see the two offset from each other.\nThere are multiple ways this can be fixed and we will look at one in Example animation with replication. But before we do, there is one important question worth thinking about: Does it matter? In this case, we can clearly see that client and server see different color of the sphere, which is all this example does, so the answer may obviously be \"yes, it matters\". But what if this was a component that creates 2 seconds-long flickering of a neon sign on random building somewhere in the background? Would it matter if one player saw it lit up for a moment while another did not? Probably not. Whenever we can get away with something being simulated only locally, we should take advantage of it. Networking complex systems is hard and prone to bugs, and network traffic is the most limited resource we have.\n\nExample animation with replication\nWhen developing multiplayer game, it is good to differentiate between simulation and presentation. Main purpose of simulation is to simulate the game logic and things going on \"under the hood\": calculating damage, keeping track of character hit-points, AI making decisions, physics simulation, evaluation of victory conditions, and so on. Presentation then produces audio-visual output that players can observe. When playing game offline in single-player mode, both simulation and presentation happen together. Same is true for player hosting a listen server. A dedicated server runs only simulation, as there is no way to observe audio-visual output of the presentation. A client connected to remote server (whether listen server or dedicated server) only presents results of the simulation that is happening remotely, but does not actually simulate anything. As a rule of thumb, in a multiplayer session exactly one machine runs simulation, but all players run presentation. Primary purpose of replication is to replicate data from machine that runs simulation to all players doing presentation.\nNoteThere are advanced techniques that hide network latency by trying to guess what the simulation will do using limited knowledge on the client. This is usually referred to as prediction because the actual simulation will happen in the future, when actions from players reach the server. For simplicity, we will ignore prediction for now.\nTo replicate our animation, we will need to do a few things:\nWe need to register our entity in replication.\nWe need to decide who is doing the simulation.\nWe need to identify parts that belong to simulation, presentation, and data that needs to be replicated from simulation to presentation.\n\nFirst change we have to make is to add an RplComponent to our entity. This will register the entity and its components for replication. In short, when there is an RplComponent on an entity, that entity along with its descendants in entity hierarchy will be scanned during initialization, collecting all replicated items (entities and components which are relevant for replication) and registering them.\nNoteWe have simplified RplComponent functionality a lot here. More in-depth description will appear later in RplNode and Replicating entities, components and hierarchies sections.\nNext, we need to decide who is doing the simulation. As we have seen in previous example, when one or more clients join a server, an instance of our entity will be created on each of them and they will all start playing the animation independently. To make them see the same animation, we need to make one of them be the source of truth, and everyone else must follow that. When we register an item for replication, it is assigned one of two roles: authority or proxy. Exactly one instance across all machines in multiplayer session is authority and everyone else is proxy. That is exactly what we need: authority is the source of truth, and proxies follow it.\nFinally, we need to decide what is simulation, what is presentation, and what to replicate. A good rule of thumb is to focus on presentation. What is the bare minimum needed to produce the audio-visual result we need? We are looking for something that is both small in size and doesn't change very often. Since our animation is just about changing color every couple of seconds, we could replicate the color value. However, color value is encoded as 32-bit RGBA, and every bit counts when it comes to network traffic. We know there is only limited number of colors we cycle through in our animation, so using color index might be even better, as it can be encoded in fewer bits. In our case, there are 4 possible colors, and we can encode their indices in just 2 bits. To keep this example short, we will not go that far and just stick to default. Still, advantage of using color index is that it is already available, while color value would have to be taken from RplExampleDebugShape. Having settled down on color index as our replicated data, it is now obvious how to divide things between simulation and presentation:\nsimulation - advances time, keeps track of color change period, and calculates new color index\nreplicated data - color index\npresentation - changing color of our debug shape using color index and rendering of debug shape\n\nAfter we have added RplComponent to our entity, we can start making changes in code.\nWe start by saying that we want to replicate color index value from authority to proxies. We do this by decorating color index with RplProp attribute. This attribute also let's us specify name of function that should be invoked on proxy whenever value of the variable is updated by replication.\n    // We mark color index as replicated property using RplProp attribute, making\n    // it part of replicated state. We also say we want OnColorIdxChanged function\n    // to be invoked whenever replication updates value of color index.\n    [RplProp(onRplName: \"OnColorIdxChanged\")]\n    private int m_ColorIdx;\nNext we change the initialization. Since our simulation happens in frame event handler EOnFrame, we only need to receive it on authority. Proxies will be reacting to changes of color index variable. If value of that variable does not change, proxies are passive and do not consume any CPU time, which is always nice.\n    override void OnPostInit(IEntity owner)\n    {\n        auto shapeEnt = RplExampleDebugShape.Cast(owner);\n        if (!shapeEnt)\n        {\n            Print(\"This example requires that the entity is of type `RplExampleDebugShape`.\", LogLevel.WARNING);\n            return;\n        }\n \n        shapeEnt.SetColorByIdx(m_ColorIdx);\n \n        // We must belong to some RplComponent in order for replication to work.\n        // We search for it and warn user when we can't find it.\n        auto rplComponent = BaseRplComponent.Cast(shapeEnt.FindComponent(BaseRplComponent));\n        if (!rplComponent)\n        {\n            Print(\"This example requires that the entity has an RplComponent.\", LogLevel.WARNING);\n            return;\n        }\n \n        // We only perform simulation on the authority instance, while all proxy\n        // instances just show result of the simulation. Therefore, we only have to\n        // subscribe to \"frame\" events on authority, leaving proxy instances as\n        // passive components that do something only when necessary.\n        if (rplComponent.Role() == RplRole.Authority)\n        {\n            SetEventMask(owner, EntityEvent.FRAME);\n        }\n    }\nWe use RplComponent to determine our role in replication. We also warn the user when RplComponent is missing on our entity as we currently require it to work correctly.\nNoteTo keep these examples game-independent, we use BaseRplComponent, which is base class of game-specific RplComponent.\nFinally, we need to modify our code for updating color index, so it changes color on both authority and proxies.\n    private void ApplyColorIdxDelta(IEntity owner, int colorIdxDelta)\n    {\n        if (colorIdxDelta == 0)\n            return;\n \n        int newColorIdx = (m_ColorIdx + colorIdxDelta) % RplExampleDebugShape.COLOR_COUNT;\n        if (newColorIdx == m_ColorIdx)\n            return;\n \n        // Update replicated state with results from the simulation.\n        m_ColorIdx = newColorIdx;\n \n        // After we have written new value of color index, we let replication know\n        // that there are changes in our state that need to be replicated to proxies.\n        // Without this call, even if we change our color index, new value would not\n        // be replicated to proxies.\n        Replication.BumpMe();\n \n        // Presentation of replicated state on authority.\n        RplExampleDebugShape.Cast(owner).SetColorByIdx(m_ColorIdx);\n    }\n \n    // Presentation of replicated state on proxy.\n    private void OnColorIdxChanged()\n    {\n        RplExampleDebugShape.Cast(GetOwner()).SetColorByIdx(m_ColorIdx);\n    }\nAnd here is the full example code:\nclass RplExample2ComponentColorAnimClass : ScriptComponentClass { }\nRplExample2ComponentColorAnimClass g_RplExample2ComponentColorAnimClass;\n \nclass RplExample2ComponentColorAnim : ScriptComponent\n{\n    private static const float COLOR_CHANGE_PERIOD_S = 5.0;\n \n    private float m_TimeAccumulator_s;\n\n    // We mark color index as replicated property using RplProp attribute, making\n    // it part of replicated state. We also say we want OnColorIdxChanged function\n    // to be invoked whenever replication updates value of color index.\n    [RplProp(onRplName: \"OnColorIdxChanged\")]\n    private int m_ColorIdx;\n\n    override void OnPostInit(IEntity owner)\n    {\n        auto shapeEnt = RplExampleDebugShape.Cast(owner);\n        if (!shapeEnt)\n        {\n            Print(\"This example requires that the entity is of type `RplExampleDebugShape`.\", LogLevel.WARNING);\n            return;\n        }\n \n        shapeEnt.SetColorByIdx(m_ColorIdx);\n \n        // We must belong to some RplComponent in order for replication to work.\n        // We search for it and warn user when we can't find it.\n        auto rplComponent = BaseRplComponent.Cast(shapeEnt.FindComponent(BaseRplComponent));\n        if (!rplComponent)\n        {\n            Print(\"This example requires that the entity has an RplComponent.\", LogLevel.WARNING);\n            return;\n        }\n \n        // We only perform simulation on the authority instance, while all proxy\n        // instances just show result of the simulation. Therefore, we only have to\n        // subscribe to \"frame\" events on authority, leaving proxy instances as\n        // passive components that do something only when necessary.\n        if (rplComponent.Role() == RplRole.Authority)\n        {\n            SetEventMask(owner, EntityEvent.FRAME);\n        }\n    }\n \n    override void EOnFrame(IEntity owner, float timeSlice)\n    {\n        int colorIdxDelta = CalculateColorIdxDelta(timeSlice);\n        ApplyColorIdxDelta(owner, colorIdxDelta);\n    }\n \n    private int CalculateColorIdxDelta(float timeSlice)\n    {\n        m_TimeAccumulator_s += timeSlice;\n        int colorIdxDelta = m_TimeAccumulator_s / COLOR_CHANGE_PERIOD_S;\n        m_TimeAccumulator_s -= colorIdxDelta * COLOR_CHANGE_PERIOD_S;\n        return colorIdxDelta;\n    }\n\n    private void ApplyColorIdxDelta(IEntity owner, int colorIdxDelta)\n    {\n        if (colorIdxDelta == 0)\n            return;\n \n        int newColorIdx = (m_ColorIdx + colorIdxDelta) % RplExampleDebugShape.COLOR_COUNT;\n        if (newColorIdx == m_ColorIdx)\n            return;\n \n        // Update replicated state with results from the simulation.\n        m_ColorIdx = newColorIdx;\n \n        // After we have written new value of color index, we let replication know\n        // that there are changes in our state that need to be replicated to proxies.\n        // Without this call, even if we change our color index, new value would not\n        // be replicated to proxies.\n        Replication.BumpMe();\n \n        // Presentation of replicated state on authority.\n        RplExampleDebugShape.Cast(owner).SetColorByIdx(m_ColorIdx);\n    }\n \n    // Presentation of replicated state on proxy.\n    private void OnColorIdxChanged()\n    {\n        RplExampleDebugShape.Cast(GetOwner()).SetColorByIdx(m_ColorIdx);\n    }\n}\nConsidering this example in isolation, things are reasonably good. It is worth mentioning that what we marked as presentation (setting color used by entity to draw the sphere) is not all of it. Truly expensive parts, rendering and audio mixing, are skipped automatically when presentation is not necessary (such as on dedicated server). If you really wanted to make sure that our presentation is only doing work when necessary, you can use RplSession.Mode() to determine whether we are running in dedicated server mode or not. In general, it is best to avoid this unless absolutely necessary.\nIn larger context of the game, if there were many of these entities placed in the world, we might start seeing constant EOnFrame calls on authority take significant amount of time. We could improve things with use of ScriptCallQueue.CallLater(), specifying delay based on our color change period. This will only work well for long color change periods (on the order of seconds) where inaccuracy introduced is not significant. However, when using very short color change periods (on the order of milliseconds) we wouldn't be able to accurately determine how many periods have passed since last call.\nIf the game also provides a replicated time value, we have another possible approach to making sure animation is in sync across all machines. We can just take this value and calculate color index from it directly. This would require either checking this replicated time periodically (such as using EOnFrame) on all machines, or using ScriptCallQueue.CallLater() with delay being an estimate of when should next color change occur. Network bandwidth cost in this case would be essentially zero for our animation. Cost of replicating time may be potentially higher, but it is constant, predictable, and it doesn't increase with number of things in the world relying on it.\n\nExample system with per-player controller\nSo far, we have seen how to make simple non-interactive animation synchronized across network, with proper distinction between simulation and presentation parts. However, games are interactive medium and players play multiplayer games to interact with others in shared virtual world. So this time we will take a look at how to let server know what a player wants to do.\nThis time, instead of having our animation change colors in predefined period, we will be changing colors in reaction to player pressing keys on the keyboard. We will also create more shapes, where each will be controlled by different key. Whenever a key corresponding to specific shape is pressed, color of the shape changes to next color in the sequence (and again, last color is followed by the first, repeating sequence from the beginning).\nWhen we have multiple players interacting with objects in single shared world, one situation we need to always consider is how to resolve conflicts when two players interact with the same object in contradicting ways. In our authoritative server architecture, there are two main ways to resolve this:\nAt any time, at most one player is allowed to interact with the object.\nMultiple players are allowed to interact with the object and server resolves conflicts when they happen.\n\nTo allow implementing both of these approaches, replication has a concept of node ownership. A client who owns a node (which means he owns all items that belong to this node) is allowed to send messages to server. Server can give ownership of a node to client (or take it back) whenever it wants.\nOwnership is natural fit for implementing the exclusive right to interact with an object. Let's say a player is only allowed to drive a car when they are sitting in driver's seat. Server gives them ownership over car when they get in the driver's seat and as soon as they leave, ownership is taken from them. Notice that there is clear moment when ownership is given to the client (sitting in the driver's seat) and taken from it (moving to another seat or leaving the car).\nThere are many cases where there is no natural moment when ownership change should occur. For example, when two players run up to some closed door and decide to open it. Giving ownership to client just to perform single action (opening the door), then taking it back, is unnecessarily complicated and will probably make the action feel clunky by adding extra latency. These situations are usually handled through some kind of server-side system which creates per-player controller. Ownership of the controller is given to the player and all interactions with this system happen through the controller.\nclass RplExample3ComponentColorAnimClass : ScriptComponentClass { }\nRplExample3ComponentColorAnimClass g_RplExample3ComponentColorAnimClass;\n \nclass RplExample3ComponentColorAnim : ScriptComponent\n{\n    [RplProp(onRplName: \"OnColorIdxChanged\")]\n    private int m_ColorIdx;\n \n    override void OnPostInit(IEntity owner)\n    {\n        auto shapeEnt = RplExampleDebugShape.Cast(owner);\n        if (!shapeEnt)\n        {\n            Print(\"This example requires that the entity is of type `RplExampleDebugShape`.\", LogLevel.WARNING);\n            return;\n        }\n \n        shapeEnt.SetColorByIdx(m_ColorIdx);\n \n        auto rplComponent = BaseRplComponent.Cast(shapeEnt.FindComponent(BaseRplComponent));\n        if (!rplComponent)\n        {\n            Print(\"This example requires that the entity has an RplComponent.\", LogLevel.WARNING);\n            return;\n        }\n    }\n \n    void NextColor()\n    {\n        m_ColorIdx = (m_ColorIdx + 1) % RplExampleDebugShape.COLOR_COUNT;\n        Replication.BumpMe();\n        RplExampleDebugShape.Cast(GetOwner()).SetColorByIdx(m_ColorIdx);\n    }\n \n    private void OnColorIdxChanged()\n    {\n        RplExampleDebugShape.Cast(GetOwner()).SetColorByIdx(m_ColorIdx);\n    }\n}\n \nclass RplExample3SystemClass : ScriptComponentClass { }\nRplExample3SystemClass g_RplExample3SystemClassInst;\n \nclass RplExample3System : ScriptComponent\n{\n    static const ResourceName s_ControllerPrefab = \"{65B426E2CD4049C3}kroslakmar/RplExampleController.et\";\n    static const ResourceName s_SpherePrefab = \"{1AD0012447ACCE3F}kroslakmar/RplExampleShape.et\";\n \n    ref RplExample3SessionListener m_SessionListener = new RplExample3SessionListener(this);\n    ref map<RplIdentity, RplExample3Controller> m_Controllers = new map<RplIdentity, RplExample3Controller>();\n \n    ref array<RplExample3ComponentColorAnim> m_Spheres = new array<RplExample3ComponentColorAnim>();\n \n    override void OnPostInit(IEntity owner)\n    {\n        if (g_Game.InPlayMode())\n            SetEventMask(owner, EntityEvent.INIT);\n    }\n \n    override void EOnInit(IEntity owner)\n    {\n        RplMode mode = RplSession.Mode();\n        if (mode != RplMode.Client)\n        {\n            RplSession.RegisterCallbacks(m_SessionListener);\n        }\n \n        if (mode == RplMode.None || mode == RplMode.Listen)\n        {\n            RplExample3Controller controller = NewController(RplIdentity.Local());\n            controller.RplGiven(null);\n        }\n \n        Resource prefab = Resource.Load(s_SpherePrefab);\n        EntitySpawnParams spawnParams = new EntitySpawnParams();\n        spawnParams.TransformMode = ETransformMode.WORLD;\n        owner.GetWorldTransform(spawnParams.Transform);\n        float xBase = spawnParams.Transform[3][0];\n        float yBase = spawnParams.Transform[3][1] + 2.0;\n        for (int y = -1; y <= 1; y++)\n        for (int x = -1; x <= 1; x++)\n        {\n            spawnParams.Transform[3][0] = xBase + x;\n            spawnParams.Transform[3][1] = yBase + y;\n            IEntity ent = g_Game.SpawnEntityPrefab(prefab, owner.GetWorld(), spawnParams);\n            m_Spheres.Insert(RplExample3ComponentColorAnim.Cast(\n                ent.FindComponent(RplExample3ComponentColorAnim)\n            ));\n        }\n    }\n \n    RplExample3Controller NewController(RplIdentity identity)\n    {\n        ref Resource controllerPrefab = Resource.Load(s_ControllerPrefab);\n        auto controller = RplExample3Controller.Cast(\n            g_Game.SpawnEntityPrefab(controllerPrefab, GetOwner().GetWorld(), null)\n        );\n        controller.m_System = this;\n        m_Controllers.Set(identity, controller);\n \n        return controller;\n    }\n \n    void DeleteController(RplIdentity identity)\n    {\n        auto controller = m_Controllers.Get(identity);\n        delete controller;\n        m_Controllers.Remove(identity);\n    }\n \n    void ChangeColor(int idx)\n    {\n        m_Spheres[idx].NextColor();\n    }\n}\n \nclass RplExample3SessionListener: RplSessionCallbacks\n{\n    RplExample3System m_System;\n \n    void RplExample3SessionListener(RplExample3System system)\n    {\n        m_System = system;\n    }\n \n    override void EOnConnected(RplIdentity identity)\n    {\n        RplExample3Controller controller = m_System.NewController(identity);\n        auto rplComponent = BaseRplComponent.Cast(controller.FindComponent(BaseRplComponent));\n        rplComponent.Give(identity);\n    }\n \n    override void EOnDisconnected(RplIdentity identity)\n    {\n        m_System.DeleteController(identity);\n    }\n};\n \nclass RplExample3ControllerClass : GenericEntityClass {}\nRplExample3ControllerClass g_RplExample3ControllerClassInst;\n \nclass RplExample3Controller : GenericEntity\n{\n    static const KeyCode s_KeyMap[] = {\n        KeyCode.KC_NUMPAD1,\n        KeyCode.KC_NUMPAD2,\n        KeyCode.KC_NUMPAD3,\n        KeyCode.KC_NUMPAD4,\n        KeyCode.KC_NUMPAD5,\n        KeyCode.KC_NUMPAD6,\n        KeyCode.KC_NUMPAD7,\n        KeyCode.KC_NUMPAD8,\n        KeyCode.KC_NUMPAD9,\n    };\n \n    RplExample3System m_System;\n    int m_IsDownMask = 0;\n \n    bool RplGiven(ScriptBitReader reader)\n    {\n        if (false)\n        {\n            SetEventMask(EntityEvent.FRAME);\n        }\n        else\n        {\n            SetEventMask(EntityEvent.FIXEDFRAME);\n        }\n        return true;\n    }\n \n    override void EOnFrame(IEntity owner, float timeSlice)\n    {\n        foreach (int idx, KeyCode kc : s_KeyMap)\n        {\n            int keyBit = 1 << idx;\n            bool isDown = Debug.KeyState(kc);\n            bool wasDown = (m_IsDownMask & keyBit);\n            if (isDown && !wasDown)\n                Rpc(Rpc_ChangeColor_S, idx);\n \n            if (isDown)\n                m_IsDownMask |= keyBit;\n            else\n                m_IsDownMask &= ~keyBit;\n        }\n    }\n \n    [RplRpc(RplChannel.Reliable, RplRcver.Server)]\n    void Rpc_ChangeColor_S(int idx)\n    {\n        if (idx < 0 || idx >= 9)\n            return;\n \n        m_System.ChangeColor(idx);\n    }\n \n    override void EOnFixedFrame(IEntity owner, float timeSlice)\n    {\n        int isDownMask = 0;\n        int keyBit = 1;\n        foreach (KeyCode kc : s_KeyMap)\n        {\n            if (Debug.KeyState(kc))\n                isDownMask |= keyBit;\n \n            keyBit <<= 1;\n        }\n        Rpc(Rpc_OwnerInputs_S, isDownMask);\n    }\n \n    [RplRpc(RplChannel.Unreliable, RplRcver.Server)]\n    void Rpc_OwnerInputs_S(int isDownMask)\n    {\n        int inputsChanged = m_IsDownMask ^ isDownMask;\n        if (!inputsChanged)\n            return;\n \n        for (int idx = 0; idx < 9; idx++)\n        {\n            int keyBit = 1 << idx;\n            bool isDown = isDownMask & keyBit;\n            bool wasDown = m_IsDownMask & keyBit;\n            if (isDown && !wasDown)\n                m_System.ChangeColor(idx);\n        }\n \n        m_IsDownMask = isDownMask;\n    }\n};\n\nGlossary\n\nServer - instance of the game that has the authority over the game state\nClient - instance of the game that connects to server\nProxy - Mirror image of an item controlled by someone else (a replica)\nItem - instance of a type with replicated state, RPCs or replication callbacks\nState - collection of properties\nProperty - member variable of a type\nRPC (Remote procedure call) - item member function that may be invoked over network\nAttribute - metadata attached to a property, member function or type\nSnapshot - copy of state at a specific point in time\nInjection - process of copying state from snapshot into an item\nExtraction - process of copying state from an item into snapshot\n\n\nConcepts\nThe core idea of our Replication System is code simplification, state synchronization and rpc delivery with the least amount of boilerplate possible.\nSingle-player, server and client code should utilize the same code path with minimal differences.\nThe authority in the system is shifted towards the server. This should bring more stability and security, but it may also create more load on the server side.\nThe Replication code is completely independent of the engine generic classes such as Entities and Components. The intention is to keep everything as lightweight as possible at a slight cost of added complexity.\n\nData flow\n\n<p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p>\nAvoiding networked races and writing a secure logic is always a big challenge. Every time a race or a security breach occurs there's is a big chance that it will take a serious amount of debugging effort to track it down and fix it. Therefore we should try to avoid them by design. Replication brings set of rules of thumb and design choices that should help:\nItem has to be explicitly inserted into the replication.\nThe aim is to reduce the amount of items inserted into replication to an absolute minimum and reduce the pollution of engine types by replication code.\nUser code is the one who knows which items should and shouldn't be replicated, therefore he is the one responsible for item registration.\n\n\nThere should always be at most one client talking to a server for a given item. Such client is the owner of the item.\nThis solves questions such as \"Who sent the RPC first?\", \"Am I safe to modify\n      the items data?\", \"Did someone override the value before I did?\".\n\n\nState is always distributed from server to clients, never the other way around.\nSynchronization from the client side would bring in the \"Feedback loop\" problem. If client changes state on the server then who should correct this client? If the server does, it will break the client data consistency which could bring adjustment from the client invoking a synchronization back to server in an infinite loop.\nThe state synchronization is basically a free access to the memory of the receiver. Allowing the synchronization from client side would be a big security risk.\nState adjustment from client to server can be accomplished by an RPC which makes the code more readable.\n\n\nPeer-to-Peer (P2P) communication is strictly forbidden. Clients can only talk to server.\nFrom the security perspective the client should always protect his sensitive data and share them only with the server. Not just positions/health/ammo_count are considered sensitive information. Also the client identity and IP are something that others shouldn't be able to access. The system would have to share those just by sending such message which is a big security violation.\nSuch communication should always be performed through trusted 3rd party which is the server.\n\n\n\n\nState replication\nIn order to get your properties replicated you need to annotate them with the property attribute. Once the item gets replicated all of the annotated properties will get checked for changes, extracted into snapshot and encoded into packets via the type Codecs. Most of the system types should have the codecs already implemented.\nProcess of state replication is roughly as follows:\non server\nReplication.BumpMe() is used to signal that properties of an item have changed and they need to be replicated to clients. This is up to users to do as necessary. Replication does not automatically check for changes on all registered items.\nReplication compares replicated properties against the most recent snapshot using codec function PropCompare(). If codec says snapshot is the same as current state, process ends.\nReplication creates new snapshot and uses codec function Extract() to copy values from instance to snapshot.\nSnapshot is transmitted to clients as needed. This process has to deal with tracking multiple snapshots per item per connected client, join-in-progress, streaming, relevancy, etc. It often uses codec function SnapCompare() to determine whether two snapshots are the same. When a snapshot is finally being prepared for transmission over network, codec function Encode() will be used to convert snapshot into compressed form (using as few bits as possible for each value) suitable for network packet.\n\n\non client\nWhen new packet with compressed snapshot arrives, it is decompressed using codec function Decode() first.\nSnapshots are compared using codec function SnapCompare() to determine whether changes have occurred.\nReplication updates properties of replicated item using codec function Inject().\n\n\n\nAbove description should give you some idea of where various codec functions fit into the state replication process, but it skips over many details. Specifically, when or if at all some codec function is called is complicated and subject to changes as replication is developed over time, so you should make no assumptions about that.\nWarningInjection always writes a new value into replicated property. For complex types (strings, arrays or classes), this means that a pointer to new instance overwrites previous pointer to the old one. Any data stored in the old instance that is not written during injection will be lost.\nSnapshots are an important part of state replication and serve to decouple extraction/injection process from encoding/decoding into network packet. Following are some of the reasons for this separation:\nThey are often used in comparisons between snapshots (SnapCompare()) or between snapshot and item state (PropCompare()). Especially second type of comparison would become more expensive if data optimized for network was used, as each property would have to be decoded again during every comparison.\nThey can be encoded into network packet in full or as delta from previous state. Having original information provides more options when creating and storing delta.\n\nThe property annotation can be expanded by a bit of metadata to influence the replication. You can detect that your properties were updated using OnRpl callback and adjust the internal state of your item. Or use a Condition for certain special cases where you would need more control over who will be receiving updates. You can find below examples of both.\n\nExamples\nclass EntityWithRplProp : GenericEntity\n{\n    [RplProp()]\n    bool bFlag;\n \n    [RplProp(onRplName: \"OnIValueChanged\")]\n    int iValue;\n \n    [RplProp(condition: RplCondition.NoOwner)]\n    float fValue;\n \n    [RplProp(customConditionName: \"MyCondition\")]\n    float fCustomCondition;\n \n    void OnIValueChanged()\n    {\n        // ...\n    }\n \n    // The custom condition can be helpful in places where you know that\n    // certain values are no longer needed on the other side. This can't be\n    // utilized to filter out connections!\n    bool MyCondition()\n    {\n        return bFlag;\n    }\n}\n\nRemote procedure calls (RPCs)\nThis is where Replication really shines. RPCs are routed to receivers by ownership rules so the user does not have to look up any identifier or address. The design leads the programmer towards uniform code in most Client/Server scenarios.\nOn sending side, codec function Extract() from corresponding RPC argument is used to create snapshot of relevant properties, and codec function Encode() then compresses this snapshot for network packet. On receiving side, codec function Decode() first decompresses data from packet into snapshot, then an instance is created and filled from snapshot using codec function Inject().\nclass EntityWithRplRpc : GenericEntity\n{\n    // This is a RPC. It has to be annotated with the RplRpc attribute.\n    [RplRpc(RplChannel.Reliable, RplRcver.Owner)]\n    void OwnerRpc(int a)\n    {\n        // ...\n    }\n \n    override void EOnFrame(IEntity owner, float timeSlice)\n    {\n        // The RPC has to be call via special method on the entity/component.\n        Rpc(OwnerRpc, 7);\n        // This call can have multiple outcomes depending on the role and\n        // ownership of this instance.\n        // 1. If this instance is the owner the RPC will be called directly\n        //    (the same way a method would be).\n        // 2. This instance is the server and some client owns the instance.\n        //    Then the RPC would be called on the owning client.\n        // 3. This is the client that does not own the instance. Then this\n        //    RPC would be dropped.\n        //\n        // You can avoid a lot of branches if you design your code around these rules.\n \n \n        // You can still use the RPC method the same way as you would use any other method.\n        // In many cases this would be the best way how to unify your logic.\n        OwnerRpc(7);\n    }\n}\n\nRPC routing table (RRT)\nThese tables specify where will be the RPC body invoked when you call it on either Server or Client engine instance.\nRPC invoked from the server: \n\nIs owner   RplRcver Server   RplRcver Owner   RplRcver Broadcast    \n\nOwner   On Server   On Server   On all Clients    \n\nNot Owner   On Server   On Client Owner   On all Clients   \n\nRPC invoke from the client: \n\nIs owner   RplRcver Server   RplRcver Owner   RplRcver Broadcast    \n\nOwner   On Server   Locally   Locally    \n\nNot Owner   Dropped   Dropped   Locally   \n\n\nCodecs\nReplication uses codecs for various types that show up as either RPC arguments or replicated properties on items. Most system types already have codecs implemented, but when you attempt to use some user-defined type in one of these cases, you will have to implement a codec yourself. Codec consists of several static functions on user-defined type T:\nbool Extract(T instance, ScriptCtx ctx, SSnapSerializerBase snapshot)\nExtracts relevant properties from an instance of type T into snapshot. Opposite of Inject().\n\n\nbool Inject(SSnapSerializerBase snapshot, ScriptCtx ctx, T instance)\nInjects relevant properties from snapshot into an instance of type T. Opposite of Extract().\n\n\nvoid Encode(SSnapSerializerBase snapshot, ScriptCtx ctx, ScriptBitSerializer packet)\nTakes snapshot and compresses it into packet. Opposite of Decode().\n\n\nbool Decode(ScriptBitSerializer packet, ScriptCtx ctx, SSnapSerializerBase snapshot)\nTakes packet and decompresses it into snapshot. Opposite of Encode().\n\n\nbool SnapCompare(SSnapSerializerBase lhs, SSnapSerializerBase rhs, ScriptCtx ctx)\nCompares two snapshots to see whether they are the same or not.\n\n\nbool PropCompare(T instance, SSnapSerializerBase snapshot, ScriptCtx ctx)\nCompares instance and a snapshot to see if any property has changed enough to require new snapshot.\n\n\n(optional) void EncodeDelta(SSnapSerializerBase oldSnapshot, SSnapSerializerBase newSnapshot, ScriptCtx ctx, ScriptBitSerializer packet)\nProduces delta-encoded packet from two snapshots. Opposite of DecodeDelta().\n\n\n(optional) void DecodeDelta(ScriptBitSerializer packet, ScriptCtx ctx, SSnapSerializerBase oldSnapshot, SSnapSerializerBase newSnapshot)\nProduces new snapshot from delta-encoded packet and an older snapshot. Opposite of EncodeDelta().\n\n\n\nNoteImplementing codec is a lot of extra work that is prone to bugs over time. Following are some cases where it may be better to not write codec and split user-defined type into parts instead:\nif a type is only ever used as an argument in one RPC\nif the codec only uses helpers and does not do anything fancy (like reducing number of bits during encoding)\nif you don't always encode all properties of the type\n\n\nHere is an example of a user-defined type ComplexType and its codec functions: class ComplexType\n{\n    bool m_Bool;\n    int m_Int;\n    string m_String;\n    float m_Float;\n    WorldTimestamp m_Timestamp;\n    vector m_Vector;\n \n    // ## Extract/Inject\n    // Extracting data from instance into snapshot, and injecting data from snapshot to instance.\n    // Snapshot is meant to be fast to work with, so values are left uncompressed\n    // to avoid extra work when accessing these values.\n \n    // ## Encode/Decode\n    // Encoding snapshot into a packet and decoding snapshot from a packet.\n    // Packets need to be as small as possible, so this process tries to reduce the\n    // size as much as it can. Knowing what range of values can certain variable have and\n    // encoding that range in minimum number of bits required is key. If you have\n    // to assume full range of values is needed, you can use helpers for different\n    // types that already implement those.\n \n    // ## EncodeDelta/DecodeDelta\n    // Optional functions for implementing encoding of snapshot differences\n    // (delta encoding). Encoding reads from old and new snapshots and writes differences\n    // between them into delta-encoded packet. Decoding then reads from old snapshot\n    // and delta-encoded packet and writes new packet based on them.\n \n    static bool Extract(ComplexType instance, ScriptCtx ctx, SSnapSerializerBase snapshot)\n    {\n        // Fill a snapshot with values from an instance.\n        snapshot.SerializeBool(instance.m_Bool);\n        snapshot.SerializeInt(instance.m_Int);\n        snapshot.SerializeString(instance.m_String);\n        snapshot.SerializeFloat(instance.m_Float);\n        snapshot.SerializeBytes(instance.m_Timestamp, 8);\n        snapshot.SerializeVector(instance.m_Vector);\n        return true;\n    }\n \n    static bool Inject(SSnapSerializerBase snapshot, ScriptCtx ctx, ComplexType instance)\n    {\n        // Fill an instance with values from snapshot.\n        snapshot.SerializeBool(instance.m_Bool);\n        snapshot.SerializeInt(instance.m_Int);\n        snapshot.SerializeString(instance.m_String);\n        snapshot.SerializeFloat(instance.m_Float);\n        snapshot.SerializeBytes(instance.m_Timestamp, 8);\n        snapshot.SerializeVector(instance.m_Vector);\n        return true;\n    }\n \n    static void Encode(SSnapSerializerBase snapshot, ScriptCtx ctx, ScriptBitSerializer packet)\n    {\n        // Read values from snapshot, encode them into smaller representation, then\n        // write them into packet.\n        snapshot.EncodeBool(packet);   // m_Bool\n        snapshot.EncodeInt(packet);    // m_Int\n        snapshot.EncodeString(packet); // m_String\n        snapshot.EncodeFloat(packet);  // m_Float\n        snapshot.Serialize(packet, 8); // m_Timestamp\n        snapshot.EncodeVector(packet); // m_Vector\n    }\n \n    static bool Decode(ScriptBitSerializer packet, ScriptCtx ctx, SSnapSerializerBase snapshot)\n    {\n        // Read values from packet, decode them into their original representation,\n        // then write them into snapshot.\n        snapshot.DecodeBool(packet);   // m_Bool\n        snapshot.DecodeInt(packet);    // m_Int\n        snapshot.DecodeString(packet); // m_String\n        snapshot.DecodeFloat(packet);  // m_Float\n        snapshot.Serialize(packet, 8); // m_Timestamp\n        snapshot.DecodeVector(packet); // m_Vector\n        return true;\n    }\n \n    static bool SnapCompare(SSnapSerializerBase lhs, SSnapSerializerBase rhs , ScriptCtx ctx)\n    {\n        // Compare two snapshots and determine whether they are the same.\n        // We have to compare properties one-by-one, but for properties with known\n        // length (such as primitive types bool, int, float and vector), we do multiple\n        // comparisons in single call. However, because we do not know length of string,\n        // we use provided function which will determine number of bytes that need\n        // to be compared from serialized data.\n        return lhs.CompareSnapshots(rhs, 4+4)   // m_Bool, m_Int\n            && lhs.CompareStringSnapshots(rhs)  // m_String\n            && lhs.CompareSnapshots(rhs, 4+8+12); // m_Float, m_Timestamp, m_Vector\n    }\n \n    static bool PropCompare(ComplexType instance, SSnapSerializerBase snapshot, ScriptCtx ctx)\n    {\n        // Determine whether current values in instance are sufficiently different from\n        // an existing snapshot that it's worth creating new one.\n        // For float or vector values, you could use some threshold to avoid creating too\n        // many snapshots due to tiny changes in these values.\n        return snapshot.CompareBool(instance.m_Bool)\n            && snapshot.CompareInt(instance.m_Int)\n            && snapshot.CompareString(instance.m_String)\n            && snapshot.CompareFloat(instance.m_Float)\n            && snapshot.Compare(instance.m_Timestamp, 8)\n            && snapshot.CompareVector(instance.m_Vector);\n    }\n \n    static void EncodeDelta(SSnapSerializerBase oldSnapshot, SSnapSerializerBase newSnapshot, ScriptCtx ctx, ScriptBitSerializer packet)\n    {\n        // Generate packet that allows other side to produce new snapshot when it already\n        // has old one available.\n \n        // We write new value of bool directly, as there is no way to reduce it below one bit.\n        // We still need to read old value from old snapshot to correctly access following\n        // properties.\n        bool oldBool;\n        oldSnapshot.SerializeBool(oldBool);\n        bool newBool;\n        newSnapshot.SerializeBool(newBool);\n        packet.Serialize(newBool, 1);\n \n        // We encode difference between old and new value of the int, and rely on the fact\n        // that difference of these values requires fewer bits to encode than value itself.\n        int oldInt;\n        oldSnapshot.SerializeInt(oldInt);\n        int newInt;\n        newSnapshot.SerializeInt(newInt);\n        int deltaInt = newInt - oldInt;\n        packet.SerializeInt(deltaInt);\n \n        // For remaining values (string, float, vector), we use single bit to signal whether\n        // value has changed and we only encode their new value if it is different from\n        // the old one.\n        string oldString;\n        oldSnapshot.SerializeString(oldString);\n        string newString;\n        newSnapshot.SerializeString(newString);\n        bool stringChanged = newString != oldString;\n        packet.Serialize(stringChanged, 1);\n        if (stringChanged)\n            packet.SerializeString(newString);\n \n        float oldFloat;\n        oldSnapshot.SerializeFloat(oldFloat);\n        float newFloat;\n        newSnapshot.SerializeFloat(newFloat);\n        bool floatChanged = newFloat != oldFloat;\n        packet.Serialize(floatChanged, 1);\n        if (floatChanged)\n            packet.Serialize(newFloat, 32);\n \n        // For timestamps, rounding of float will occur when absolute value of\n        // difference is more than 16777216ms (~4.5 hours). Also, past certain\n        // point, differences cannot be represented as 32-bit int either. Therefore,\n        // once difference cannot be sent accurately, we instead send full value.\n        // This might not be the best solution for extreme uses, but it demonstrates\n        // how one can implement delta-encoding using domain-specific knowledge.\n        WorldTimestamp oldTimestamp;\n        oldSnapshot.SerializeBytes(oldTimestamp, 8);\n        WorldTimestamp newTimestamp;\n        newSnapshot.SerializeBytes(newTimestamp, 8);\n        float deltaMs = newTimestamp.DiffMilliseconds(oldTimestamp);\n        bool isUsingDelta = -16777216.0 <= deltaMs && deltaMs <= 16777216.0;\n        packet.Serialize(isUsingDelta, 1);\n        if (isUsingDelta)\n        {\n            int deltaMsInt = deltaMs;\n            packet.SerializeInt(deltaMsInt);\n        }\n        else\n        {\n            packet.Serialize(newTimestamp, 64);\n        }\n \n        vector oldVector;\n        oldSnapshot.SerializeVector(oldVector);\n        vector newVector;\n        newSnapshot.SerializeVector(newVector);\n        bool vectorChanged = newVector != oldVector;\n        packet.Serialize(vectorChanged, 1);\n        if (vectorChanged)\n            packet.Serialize(newVector, 96);\n \n        // More techniques are possible when modification patterns are known. For example,\n        // when multiple properties are always modified together, they could share single\n        // bit that would say whether there were any changes (and new values were encoded)\n        // or not.\n    }\n \n    static void DecodeDelta(ScriptBitSerializer packet, ScriptCtx ctx, SSnapSerializerBase oldSnapshot, SSnapSerializerBase newSnapshot)\n    {\n        // Generate new snapshot using data from old snapshot and packet.\n        // Note that even when value from old snapshot is not used because packet carries\n        // new value, we always read it to make sure we correctly access following\n        // properties that may not have changed.\n \n        // Bool value is read directly from packet, just as it was written.\n        bool oldBool;\n        oldSnapshot.SerializeBool(oldBool);\n        bool newBool;\n        packet.Serialize(newBool, 1);\n        newSnapshot.SerializeBool(newBool);\n \n        // New value of int is reconstructed by applying delta to old value.\n        int oldInt;\n        oldSnapshot.SerializeInt(oldInt);\n        int deltaInt;\n        packet.SerializeInt(deltaInt);\n        int newInt = oldInt + deltaInt;\n        newSnapshot.SerializeInt(newInt);\n \n        // Remaining properties are reconstructed by checking whether they changed\n        // and either reading new value from packet, or copying old value.\n        string oldString;\n        oldSnapshot.SerializeString(oldString);\n        bool stringChanged;\n        packet.Serialize(stringChanged, 1);\n        string newString;\n        if (stringChanged)\n            packet.SerializeString(newString);\n        else\n            newString = oldString;\n        newSnapshot.SerializeString(newString);\n \n        float oldFloat;\n        oldSnapshot.SerializeFloat(oldFloat);\n        bool floatChanged;\n        packet.Serialize(floatChanged, 1);\n        float newFloat;\n        if (floatChanged)\n            packet.Serialize(newFloat, 32);\n        else\n            newFloat = oldFloat;\n        newSnapshot.SerializeFloat(newFloat);\n \n        WorldTimestamp oldTimestamp;\n        oldSnapshot.SerializeBytes(oldTimestamp, 8);\n        bool isUsingDelta;\n        packet.Serialize(isUsingDelta, 1);\n        WorldTimestamp newTimestamp;\n        if (isUsingDelta)\n        {\n            int deltaMsInt;\n            packet.SerializeInt(deltaMsInt);\n            float deltaMs = deltaMsInt;\n            newTimestamp = oldTimestamp.PlusMilliseconds(deltaMs);\n        }\n        else\n        {\n            packet.Serialize(newTimestamp, 64);\n        }\n        newSnapshot.SerializeBytes(newTimestamp, 8);\n \n        vector oldVector;\n        oldSnapshot.SerializeVector(oldVector);\n        bool vectorChanged;\n        packet.Serialize(vectorChanged, 1);\n        vector newVector;\n        if (vectorChanged)\n            packet.Serialize(newVector, 96);\n        else\n            newVector = oldVector;\n        newSnapshot.SerializeVector(newVector);\n    }\n}\n\nNetworked logic\nYou will have to start thinking at a bigger scale If you want to write readable and unified replication code. Keep in mind that you want to reuse the most of your replication code and still keep it readable for all of the application use-cases (listen server, dedicated server, single-player). This is not an easy task but trust me it will save you time and a lot of typing in the long run.\nTo give you more context about the current usage of your item the replication uses RplNode structures. These are immutably bound to your items and function as a proxy between your code and replication layer. I won't talk about how to create and maintain them as it will be explained in depth later on. Now they will just give us two pieces of context: Role and Ownership. These are the strongest tools you will get from the replication layer. Lets look at an example:\n// The task is to control a car in multiplayer.\nclass CarControllerComponent : ScriptComponent\n{\n    // Lets assume that we already got the node from somewhere.\n    private RplNode m_Node;\n \n    // We would like our logic to fulfill following constraints.\n    // 1. Server is in charge of the transformation of the car.\n    // 2. The player provides input to move the car around.\n    // 3. Everybody should see the car moving.\n    override void EOnFrame(IEntity owner, float timeSlice)\n    {\n        // Theres three parts that wee need to be handled.\n \n        // 1. Authority (the server)\n        // There are only two roles at the moment (Authority and Proxy).\n        if(m_Node.Role() == RplRole.Authority)\n        {\n            CalculateNewTransform(...);\n        }\n \n        // 2. Owner (the driving client)\n        if(m_Node.IsOwner())\n        {\n            SendInput(...);\n        }\n \n        // 3. Everybody\n        MoveCar(...);\n    }\n \n    void CalculateNewTransform(...)\n    {\n        // ...\n        // Calculate new target transformation based on players input.\n        // ...\n    }\n \n    void SendInput(...)\n    {\n        if (KeyDown(...))\n        {\n            // ...\n            // Send to authority Throttle/Break.\n            // ...\n            // Send to authority Left/Right.\n            // ...\n        }\n        // For authority only localy record the input.\n        // RPCs do this automatically for you but that will be covered later.\n    }\n \n    void MoveCar(...)\n    {\n        // ...\n        // Move the car when authority provides new target transformation.\n        // ...\n    }\n}\nRplRoleRplRoleRole of replicated node (and all items in it) within the replication system.Definition RplRole.c:14\nIEntityDefinition IEntity.c:13\nRplNodeDefinition RplNode.c:13\nRplNode.IsOwnerproto external bool IsOwner()\nScriptComponentParent class for all components created in script.Definition ScriptComponent.c:24\nScriptComponent.EOnFramevoid EOnFrame(IEntity owner, float timeSlice)Event every frame.\nNow put the above example into different settings and debug whats happening.\n\nSetting 1: Listen server and a client\nTwo car instances. One owned by the server player and second owned by the client.\nServer and his car: CalculateNewTransform() → SendInput() → MoveCar()\nServer and client's car: CalculateNewTransform() → MoveCar()\nClient and server's car: MoveCar()\nClient and his car: SendInput() → MoveCar()\n\nOur constraints hold for both of our instances on both sides. The server controls the transform, car owner provides input and everybody is moving both of the instances around.\n\nSetting 2: Dedicated server and two clients\nTwo car instances (car1, car2). One owned by each client (client1, client2).\nServer car1: CalculateNewTransform() → MoveCar()\nServer car2: CalculateNewTransform() → MoveCar()\nClient1 car1: SendInput() → MoveCar()\nClient1 car2: MoveCar()\nClient2 car1: MoveCar()\nClient2 car2: SendInput() → MoveCar()\n\nOnce again our constraints hold for all instances on all sides. The server controls the transformations of both cars and every client can control only his own car. Everybody sees cars moving.\n\nSetting 3: Single-player\nOne car on single instance (\"server\" that doesn't allow client connections). There is no need to call different code path or make specific changes for single-player. Roles and ownership should take care of the logic.\nServer: CalculateNewTransform() → SendInput() → MoveCar()\n\nAs you can see there is no difference in behavior. The player would be still able to drive the car even when not running a multiplayer game.\n\nTakeaway - TLDR\nThe replication provides you with tools to structure your networked code in minimal and readable manner.\nThere's a bit of mental gymnastics involved along with a few rules of thumb that will carry you through the process:\nBase your logic around the roles and ownership.\nYour code will be running in more than one setting. Verify that your assumptions also work for the others.\nUse real examples to reason about the design and put them into context of different settings**.\nBefore reaching out to some utility like \"IsDedicatedServer()\" or \"IsClient()\" think twice**.\nThese will be available somewhere in the codebase but instead of making your job easier they will make it much much harder.\nThink of those as usage of hardcoded constants instead of adaptible state machine.\n\n\nWhen you find a case where these tools don't fit then this is not your hammer. Use something else.\nAlways proceed with caution. - Nothing takes longer than fixing a bug in distributed asynchronous codebase.\n\n\nItem registration\n\nLightweight using enf::RplNode\nAny enf::BaseItem derived object (Item) can utilize the State synchronization and rpcs. We will discuss in this section how to integrate replication into the codebase and what we will get from doing so.\nDerive your classes/structs from enf::BaseItem and properly implement the ENF_DECLARE_ITEM(...) macro. This is a crucial step! Beware!\nNow you need an enf::RplNode or its derived instance that will serve as the container for your Items. Here you have a couple of options:\nJust raw instantiate the enf::RplNode.\nMake the enf::RplNode member of one of the items.\nDerive one of Items from the enf::RplNode.\n\n\nWhen all of your Items are constructed and ready insert them into the node via his API.\n(optional) The enf::RplNode is a hierarchical structure. You may set the parent child relations between your nodes at this point.\nCall the self registration method of the enf::RplNode InsertToReplication(...) (or its replacement if defined in the derived type).\n\n\n<p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p>\nNow you should have your items successfully registered and ready to synchronize their state and send/receive RPC messages.\nYour items will receive the RplId (a unique identifier in the networked environment), replication role and ownership information. You should design your logic around these as they will help you to unify your code for every use-case using replication (single player, listen server, dedicated server, client).\nTodoNode owner (first item in the node) → Creation + Destruction\n\nEntity system using gamelib::BaseRplComponent\nTodoease of use and relation to RplNode ...\n\nStreaming\nTodoItem creation, destruction, hierarchy and overall lifetime in replication. (The complicated stuff ...)\n\nLife cycle\nTododraw\n\nCaveats\n\nWhen running multiple instances of the GameApp with -forceupdate flag on the same machine consider using also -maxFPS XX flag to balance out the load of both instances. Otherwise you could end up with foreground instance running at 200 fps and the background instance at 5fps because of the operating system prioritization.",
    "filename": "Page_Replication_Overview.html"
  },
  {
    "title": "RplNode",
    "source": "enfusion",
    "content": "Immutable collection of replicated items.\nWarningWork in Progress!\n\nRole in replication\nNodes describe the relations of singular Items within the system. They represent a single immutable structure that shares the lifetime properties, creation and initialization process.\nYou can think of them as a collection of entities and their components contained in a prefab instance. Those were designed to work together and probably to be spawned and destroyed at the same time.\n\nNode contents\nThe node itself is just an array of structures. You can fill it with your items as you see fit with one exception. The first inserted item had to be the Head item. This special item has to implement replication lifetime specific callbacks. These are for example able to recreate the contents of this node, destroy him, move him within the hierarchy of other nodes, save and load initialization data.\n\nTypes of nodes\nThere are generally three types of nodes reflecting the environment from which they were registered. Each of them will receive a different type of RplId.\n\nLoadtime\nThe node will be present on both server and clients after the world file gets loaded.\nNote: These kinds of nodes don't have to implement a callbacks which are \"streaming\"(creating) them on clients.\n\n\nRuntime\nThose will be always created on the fly on server. He will distribute them to clients on demand.\n\n\nLocal\nThose will be created on the fly during runtime on the client.\nThey would not be streamed to server and cannot influence the experience of other clients.\nEffectively just local effects which still share the capabilities of replicated objects (really cool tool to de-duplicate your code).\n\n\n\n\nNode Lifetime\n\nCreation\n\nAllocate your node (his memory is owned by the user).\nInsert the Head item.\nInsert the rest of your items.\nRegister your node into the replication.\n\nThis is a really straight forward process but there is one caveat. You always have to be aware of when you are registering your node. In general there are only two phases influencing the registration process.\n\nLoading phase\n\nYour nodes will be treated as Static by default. You have to account for that otherwise you will be greeted with a replication error telling you that you broke the loading table consistency.\nIf you know that your node is getting registered in load time and you know that it won't be spawned on clients you can override the registration logic and tell the system to register it as Dynamic node instead.\n\n\nRuntime phase\n\nEverything registered in this phase will be treated as Dynamic by default on server and Local by default on clients. Trying to override this is most probably pointless and just would not work.\n\n\nRuntime\nThe node will get assigned some meta information right after it is created. Those are related to ownership and role. You can use these right from the start to build your logic around them. All of the contained Items will get an RplId assigned after the node gets registered. This is a unique identifier synchronized across the network.\nDuring runtime the node along with the Head item serves as your access point to the replication related data and its features.\nWhen this nodes becomes relevant to a client then a procedure called Node Streaming will be initiated. There will be whole chapter on this topic.\n\nDestruction\nOnce you know that the items in the node are getting deleted you should unregister the node from replication first. Otherwise there would be a whole lot of nasty crashes happening. You can free the items and eventually your node. Outgoing communication from your items would be properly finalized and destruction will be replicated to your items.\n\nHow to\nThe nodes are really straight forward to use on their own. The most common use case would be the BaseRplComponent which combines both, the RplNode with Head item all together. Or the Connection which is not part of the entity component structure. Note that your logic does not have to be written in entities and components in order to use the replication and RplNodes you are completely free to structure your code however you like. The only limitation is that your items have to inherit from the BaseItem and properly use the related macros.",
    "filename": "Page_Replication_RplNode.html"
  },
  {
    "title": "World Systems",
    "source": "enfusion",
    "content": "Introduction\nWorld systems are means to perform some operations at various stages of world update loop. They are meant to complement entities and their components. Usually world system implements some feature using entities and components in the world, similar to how a puppeteer would use puppets to perform a stage play.\nWorld systems differ from entities and components in a few ways:\nOnly one instance of particular world system type can be created for particular world. On the other hand, there can be many instances of single entity type in a world, and each entity instance may have possibly multiple components of same type on it.\nEntities can be organized into hierarchies and have position and orientation in the world. World systems do not - while they are tied to the world, they do not exist on specific location inside of it.\nEntities are updated one after another, and order in which their updates happen, is not defined. World systems can affect their order of updates through dependencies between them.\nWorld file holds all entities and components which will be created in the world when it is loading (though more entities may be created after gameplay starts). What world systems will be instantiated is specified using a config file that is independent of the world.\n\nTo demonstrate how world systems and entities with components would be used to build gameplay, let's use a simple FPS game where players spawn on spawn points placed in map. Game supports both deathmatch and team-deathmatch modes. Spawn points are represented as entities in the world. They are also assigned to specific teams either through property on entity itself, or on a component attached to entity that is dedicated to holding team affiliation information. We would then implement logic for score counting and player spawning for our two game modes using world systems. By switching configuration of these systems, we can run the map in deathmatch or team-deathmatch mode. If we are running in deathmatch mode, we can use all spawn points when determining where a player should spawn. If we are running in team-deathmatch mode, our respawn logic will be also taking into account team affiliation of each spawn point, ensuring players do not respawn in the middle of enemy territory.\nPrevious description has been intentionally very simple and vague. Goal was to give a rough idea of how things fit together without going into too many details. In a real game, there may be many more systems driving a world (tens to even hundreds), many of which may be shared across all game modes, while others would be specific to particular game mode. Mods may also alter behavior of systems, implement their own and organize them to create new game modes.\n\nCreating and using world system\nLet us take a look at how a world system is implemented and integrated in the game.\nThere are a few things necessary for every world system to work:\nYour world system class must be derived from WorldSystem or one of its subclasses.\nYou need to override WorldSystem.InitInfo().\nIn your implementation of InitInfo() function, you set information about your world system so that engine knows how to handle it.\n\nRemarksArma Reforger previously used a legacy version of world systems. This document will refer to these as \"legacy systems\". Differences between current and legacy systems will be described as they come up. To make transition easier, there is support for migrating systems gradually from legacy to new version. A world system will follow legacy rules if it does not override InitInfo(). Once InitInfo() is provided, all information will be taken from WorldSystemInfo and legacy sources will only be used for mismatch warnings. Eventually, this support for legacy sources will be dropped altogether, so it is best to migrate as soon as possible. \n\nIn legacy version, your world system had to be subclass of BaseSystem instead of WorldSystem.\nFollowing code is an example of very simple world system, with each of the above points marked. class HelloWorldSystem : WorldSystem // 1.\n{\n    override static void InitInfo(WorldSystemInfo outInfo) // 2.\n    {\n        outInfo.SetAbstract(false); // 3.\n    }\n \n    void HelloWorldSystem()\n    {\n        Print(\"Hello world (systems)\");\n    }\n}\nAfter we recompile and reload scripts in workbench, we are done defining our world system in script. But we won't be able to see it in game just yet. For that, we need to run the game with config that references our world system, so we either have to create new config, or add it to an existing one. In practice, you will most likely be adding your world system to existing config, but to demonstrate all steps of the process, we will be creating new config from scratch.\nTo create new world system config:\nIn \"Resource Browser\", select directory where you want to place your config, right-click in an empty space and choose \"Config file\" in \"Create Resource\" section of the context menu.\nType name of your config file.\nChoose \"SystemSettings\" as config class.\n\n   \nYou should now see your new config file in \"Resource Browser\". From here on, the process is the same same as adding to an existing config:\nDouble-click on the config file in \"Resource Browser\" to open it.\nAdd new entry to \"Systems\" array using \"+\" button.\nSearch for your new world system type, then select it by clicking on it.\n\n  \nYou should now have your world system added to the end of the \"Systems\" array. When this config is used to run a world, world systems listed in the \"Systems\" array will be created.\nSteps for running world with particular config are specific to each game so we won't go into that here. However, for testing, \"World Editor\" supports selecting one of predefined configs to use in \"Play Mode\". For our config to appear in this list, we need to add it there first:\nIn main workbench window menu at the top, go to \"Workbench\", then \"Options\".\nIn \"Game Project\" tab, in bottom part scroll down to \"Modules\" section, looking for \"System Module Settings\".\nAdd your config to the \"Configs\" array.\n\n  \nIf you now open some world in World Editor, you can go to \"Play Mode\" button dropdown menu, \"World Systems Config\" submenu, and see your config there. Clicking it will select it for use when entering \"Play Mode\". With your config selected, if you now enter play mode, you should see the message from HelloWorldSystem constructor appear in log. This shows us that our world system has been created and everything works as expected.\nWorld systems can be queried at runtime as well. To try it out, you can paste following code into Remote Console of Script Editor while you are in play mode with HelloWorldSystem created (note that this script relies on GetGame() function, which might not be available in all projects). // Make sure you are using correct world, as there may be multiple worlds in\n// some situations and main game world is not always the one you want.\nWorld world = GetGame().GetWorld();\n \n// Once you have the world, you query it for particular system.\nWorldSystem foundSystem = world.FindSystem(HelloWorldSystem);\nPrint(foundSystem);\nPrintproto void Print(void var, LogLevel level=LogLevel.NORMAL)Prints content of variable to console/log.\nHelloWorldSystem[Hello world system]Definition WorldSystemsDocs.c:553\nWorldSystemTo create a system, you just need to create a class which inherits from WorldSystem,...Definition WorldSystem.c:17\nWorldderived class connected to gamelib to implement game related featuresDefinition World.c:16\nWorld.FindSystemproto external WorldSystem FindSystem(TypeName type)Find a world system based on its type.\n\nWorld system information\nLet us now go back to the HelloWorldSystem.InitInfo() function we implemented in our example. This function has only one purpose: to fill WorldSystemInfo instance with information about our system. Each world system has some meta-information associated with it, which is stored in WorldSystemInfo. Engine uses this information for various purposes: ordering of updates, dependencies between world systems, determining whether instance of world system should be created in some situation, and so on. We will be going over various WorldSystemInfo properties in related sections.\nMain reason for this approach is to allow derived classes and mods to inherit as much of the information from the original system, making changes to only those properties they need to. Here is an example of how someone might decide to mod our HelloWorldSystem in order to introduce per-frame updates to it: modded class HelloWorldSystem\n{\n    override static void InitInfo(WorldSystemInfo outInfo)\n    {\n        super.InitInfo(outInfo); // 1.\n        outInfo.AddPoint(WorldSystemPoint.Frame); // 2.\n    }\n \n    private int m_FrameCount = 0;\n \n    override void OnUpdatePoint(WorldUpdatePointArgs args)\n    {\n        if (args.GetPoint() == WorldSystemPoint.Frame)\n        {\n            int frameIndex = m_FrameCount;\n            PrintFormat(\"Hello world (systems) frame %1\", frameIndex);\n \n            m_FrameCount += 1;\n \n            // Stop when we've done 10 frame updates (printed frame numbers from 0 to 9).\n            if (m_FrameCount == 10)\n                this.Enable(false);\n        }\n    }\n}\nImportant bits are:\nCalling InitInfo() implementation of base class (or class being modded), letting it do its thing.\nMaking changes necessary for our implementation.\n\nDefault values of WorldSystemInfo properties are well defined, but you might not always be able to rely on them. Specifically, all world systems implemented in native code get to modify these default values in WorldSystemInfo before InitInfo() is called. The only system that guarantees to leave default values unchanged is WorldSystem. If it is necessary to ensure that WorldSystemInfo has everything set to default, one can use WorldSystemInfo.RestoreDefaults() to achieve it.\nWarningUsing WorldSystemInfo.RestoreDefaults() should be considered last resort. In almost all cases, it is better to use more fine-grained operations, otherwise you risk maintenance issues further down the line.\nWith the exception of WorldSystemInfo.RestoreDefaults(), all WorldSystemInfo functions follow same naming convention, which puts together operation and property on which this operation happens. Based on operations available, there are two kinds of properties:\nSingle-value properties, which only provide Set*() operation.\nWorldSystemInfo.SetAbstract()\n\n\nSet-like properties, which provide Add*(), Remove*() and Clear*() operations.\nWorldSystemInfo.AddPoint()\nWorldSystemInfo.RemovePoint()\nWorldSystemInfo.ClearPoints()\n\n\n\nWarningWhile InitInfo() function allows one to write anything they want, in most cases the implementation should be very simple. For this reason, there is no support for querying property values. Highly suspicious things include (but are not limited to):\nany kind of control flow (branches, loops)\nfunction calls other than super.InitInfo() or WorldSystemInfo member functions\nside-effects other than changes in WorldSystemInfo\nreliance on any kind of state of classes or variables (including global or static variables)\n\n\n\nWorld system points\nEvery world system can register for notifications at particular points during world lifetime. We have already seen how this is done in previous example, so let's look at it again: override static void InitInfo(WorldSystemInfo outInfo)\n{\n    super.InitInfo(outInfo); // 1.\n    outInfo.AddPoint(WorldSystemPoint.Frame); // 2.\n}\nRemarksLegacy system specifies system points using config property \"System Points\" which can be modified in world system config.\nWhen we initialize WorldSystemInfo, we call WorldSystemInfo.AddPoint(), passing WorldSystemPoint.Frame as argument (marked by 2. in the example). This tells engine that our world system wants to be notified at this system point.\nRemarksWorldSystemPoint enum was previously called ESystemPoint. Old name is still provided as an alias, but it is deprecated and will be removed in the future.\nThere are several system points that world systems can register to. For a full list you can refer to WorldSystemPoint. In short, there are two kinds of system points: update points and one-time points. Update points occur during world update loop periodically. On the other hand, one-time points occur only once during lifetime of particular world and its associated world systems. Many of them are related to entity events (see EntityEvent) and thus follow similar rules. For example, every iteration of world update loop is guaranteed to hit WorldSystemPoint.Frame (same as EntityEvent.FRAME) exactly once. On the other hand, WorldSystemPoint.FixedFrame (same as EntityEvent.FIXEDFRAME) may be hit zero or more times, depending on how much time one iteration of world update loop took and what is the fixed timestep logic used by particular game.\nIf a world system is registered for notification on at least one system point of particular kind, corresponding notification function will be called whenever that point is hit. For update points, notification function is OnUpdatePoint(), while for one-time points it is OnOneTimePoint().\nRemarksLegacy version only supports update points, for which it calls notification function OnUpdate().\nIt is also possibly to affect the relative ordering of world systems that registered to same system point. To do so, WorldSystemInfo has ExecuteBefore and ExecuteAfter properties that can be used to specify ordering constraints.\nWarningUnless two systems have execution constraint specified between them (either through ExecuteBefore on first, or through ExecuteAfter on second), their ordering is undefined. In practice, these two systems without execution constraint will execute in some order, and that order may appear to stay the same for some time, but there is no guarantee that it will stay the same forever.\nHere is an example of a system that uses multiple system points and specifies execution constraint on our HelloWorldSystem from previous examples: class MultiPointSystem : WorldSystem\n{\n    override static void InitInfo(WorldSystemInfo outInfo)\n    {\n        outInfo\n            .SetAbstract(false)\n            // 1.\n            .AddPoint(WorldSystemPoint.Frame)\n            .AddPoint(WorldSystemPoint.FixedFrame)\n            .AddPoint(WorldSystemPoint.SimulatePhysics)\n            // 2.\n            .AddExecuteBefore(HelloWorldSystem, WorldSystemPoint.Frame);\n    }\n \n    private int m_FrameCount = 0;\n    private int m_FixedFrameCount = 0;\n    private int m_SimulatePhysicsCount = 0;\n \n    override void OnUpdatePoint(WorldUpdatePointArgs args)\n    {\n        switch (args.GetPoint())\n        {\n        case WorldSystemPoint.Frame:\n            PrintFormat(\"MultiPointSystem Frame %1\", m_FrameCount);\n            m_FrameCount += 1;\n            break;\n        case WorldSystemPoint.FixedFrame:\n            PrintFormat(\"MultiPointSystem FixedFrame %1\", m_FixedFrameCount);\n            m_FixedFrameCount += 1;\n            break;\n        case WorldSystemPoint.SimulatePhysics:\n            PrintFormat(\"MultiPointSystem SimulatePhysics %1\", m_SimulatePhysicsCount);\n            m_SimulatePhysicsCount += 1;\n            break;\n        }\n \n        int total = m_FrameCount + m_FixedFrameCount + m_SimulatePhysicsCount;\n        if (total >= 100)\n            this.Enable(false);\n    }\n}\nRemarksLegacy systems can provide virtual function bool DependsOn(WorldSystemPoint point, WorldSystem system)\nWorldSystemPointWorldSystemPointDefinition WorldSystemPoint.c:13\n to describe dependencies. This is similar to ExecuteAfter in that when this function returns true for particular combination of point and system, it will be as if that combination of point and system was added to ExecuteAfter set. There is no ExecuteBefore equivalent available for legacy systems.\nThis system registers to three system points (1.). It also adds one execution constraint using WorldSystemInfo.AddExecuteBefore() (2.). This constraint says that in WorldSystemPoint.Frame, MultiPointSystem.OnUpdatePoint() must execute before HelloWorldSystem.OnUpdatePoint().\nRest of the code demonstrates different behavior of various system points. It counts how many times was particular system point hit and prints messages with system point and its hit index. After enough hits have been printed, system disables itself, preventing further calls to OnUpdatePoint().\nNow add MultiPointSystem to our previously created config that already contains HelloWorldSystem and run a world using this config. Based on order in which log messages from each system appear, you can see that HelloWorldSystem and MultiPointSystem execute WorldSystemPoint.Frame in order we specified. You can try to change constraint from ExecuteBefore to ExecuteAfter to see messages appear in the opposite order. Or you can remove execution constraint altogether and see in what order they execute afterwards (though don't rely on it to stay the same).\nNoteInstead of ExecuteBefore on MultiPointSystem, we could have set ExecuteAfter on HelloWorldSystem which would have the same effect (of course, changing what system is passed to it as well). In most cases it doesn't matter where constraint is specified, but good practice is to prefer specifying it in system that you are maintaining, instead of adding or modding it into someone else' system.\nVery likely you will also notice that number of hits at the end is different for each system point we registered. This is because of different system points having different relation to world update loop. WorldSystemPoint.SimulatePhysics might not appear at all if there are no objects that require simulation of physics. However, order in which these system points are hit (assuming they are hit at all) is guaranteed. Describing world update loop in detail is outside the scope of world systems, though.\n\nWorld system configuration\nWorld systems can declare variables that will be exposed in world system config. This is done by decorating variable declarations with Attribute. These variables will then be initialized by engine and world system can use them at runtime.\nHere is an example of exposing variables in world system config: class ConfigurableSystem : WorldSystem\n{\n    override static void InitInfo(WorldSystemInfo outInfo)\n    {\n        outInfo.SetAbstract(false);\n    }\n \n    [Attribute(defvalue: \"2\")] // 2.\n    private int m_ConfigInt; // 1.\n \n    void ConfigurableSystem()\n    {\n        PrintFormat(\"ConfigurableSystem.ctor m_ConfigInt = %1\", m_ConfigInt); // 3.\n    }\n}\n\nWe declare member variable m_ConfigInt which will be initialized from config.\nWe decorate it using Attribute to let engine know that m_ConfigInt should be exposed through config, as well as how to expose it (in this case, what should be its default value).\nWe print value of m_ConfigInt we obtained from config.\n\nRunning world with this world system will produce a message in log, showing that value of m_ConfigInt will match whatever you set in the config (2 by default).\nNoteIn general, a world system can also change its behavior based on entities present in the world. Whether some configuration option should come from world system config, or from an entity in the world, is sometimes not clear. Ideally, configuration in world system config should be independent from worlds themselves so that one config can be used with different worlds. Things which are specific to particular world should be stored in that world. However, there are also ambiguous situations which are hard to categorize. In those cases, one should consider pros and cons of either approach and decide accordingly. Sometimes, there just isn't a simple answer.\n\nSupport for class hierarchies\nLet's say we want to model multiple game modes by having one common base class for them (derived from WorldSystem) which defines common interface of all game modes. For two game modes (using deathmatch and team-deathmatch example from Introduction) we would like to have following inheritance relationship:\n\n<p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p>\nWe would also like to enforce a few rules:\nOnly one game mode can be created at a time.\nIt shouldn't be possible to create GameMode itself as it is just defining interface without implementation, only full implementations can be created.\nOthers can search for GameMode type using World.FindSystem() and obtain created game mode.\n\nEnforcing rule 2 is the easiest and we have already seen it before in previous examples: Abstract property of WorldSystemInfo. Basically, abstract systems cannot be instantiated and they will not appear as option when editing world system config. All world systems derived from WorldSystem are abstract by default. In all of our previous examples, we were marking world systems as not abstract so we could add them to world system config. This time, we will do the opposite and mark GameMode as abstract.\nRemarksLegacy systems implemented in script are not abstract and they can always be instantiated. It is not possible to change this.\nRules 1 and 3 may seem unrelated at first, but we can solve them together. If you look at World.FindSystem() function, you will notice that it can return at most one world system instance for particular type. Behavior of FindSystem(type) can be summarized as follows: If type is unique (or derived from unique type), then it returns the one instance that can be safely cast to this type (or null if there is no such world system instance). For all other types, it only returns instances that match the type exactly, ignoring inheritance relationships. This brings us to Unique property of WorldSystemInfo. When a world system type is marked as unique using this property, only one world system that is derived from this unique type can be created at runtime. In other words, if we make GameMode type unique, we will enforce that only one implementation of game mode will be created at runtime and also make World.FindSystem() allow searches for GameMode type to return this game mode implementation.\nHere is what it would all look like in the code. class GameMode : WorldSystem\n{\n    override static void InitInfo(WorldSystemInfo outInfo)\n    {\n        // 1.\n        outInfo\n            .SetAbstract(true)\n            .SetUnique(true);\n    }\n \n    // 2.\n    override protected void OnInit()\n    {\n        Print(\"GameMode.OnInit()\");\n    }\n \n    // 3.\n    void Notify();\n}\n \nclass DeathmatchMode : GameMode\n{\n    override static void InitInfo(WorldSystemInfo outInfo)\n    {\n        // 1.\n        outInfo.SetAbstract(false);\n    }\n \n    // 2.\n    override protected void OnInit()\n    {\n        Print(\"DeathmatchMode.OnInit()\");\n    }\n \n    // 3.\n    override void Notify()\n    {\n        Print(\"DeathmatchMode.Notify()\");\n    }\n}\n \nclass TeamDeathmatchMode : GameMode\n{\n    override static void InitInfo(WorldSystemInfo outInfo)\n    {\n        // 1.\n        outInfo.SetAbstract(false);\n    }\n \n    // 2.\n    override protected void OnInit()\n    {\n        Print(\"TeamDeathmatchMode.OnInit()\");\n    }\n \n    // 3.\n    override void Notify()\n    {\n        Print(\"TeamDeathmatchMode.Notify()\");\n    }\n}\n\nWe set GameMode WorldSystemInfo properties Abstract and Unique to true, preventing creation of GameMode itself, and also requiring that at most one type derived from GameMode can be created. Actual game mode implementations have Abstract set to false.\nWe use OnInit() to see which game mode is created by printing messages specific to each game mode.\nWe also declare a GameMode.Notify() function that can be invoked by rest of the game without knowing which game mode is actually running.\n\nIf you now run world with either DeathmatchMode or TeamDeathmatchMode, you will see corresponding message from OnInit() in log. You can also test in Remote Console of Script Editor that Notify() can be called without knowing which game mode exactly is created: World world = GetGame().GetWorld();\nGameMode gameMode = GameMode.Cast(world.FindSystem(GameMode));\ngameMode.Notify();\nGameMode[Configurable system]Definition WorldSystemsDocs.c:660\nGameMode.Notifyvoid Notify()\nRemarksLegacy systems are marked as unique automatically based on their base class. If their direct base class is either WorldSystem or GameSystem, they are marked as unique. It is not possible to change this.\n\nReplication of world systems\nNoteThis section requires some understanding of replication and replication-related terminology. If you can't understand something, feel free to ignore it. Things will make more sense once you get familiar with replication as well.\nAll world systems support replication and can work in multiplayer. It is up to author of the system to decide whether that is necessary or not. In some cases, a world system naturally only exists on client (eg. sound system) or only on server (eg. hit registration that does lag compensation). In other cases, a world system needs to be replicated between server and clients.\nFor a world system to be replicated, it must be registered in replication. This is done automatically when all following conditions are met:\nIt must exist on both server and clients (we'll get to that in World system location section).\nIt must have some replicated state, RPC, or replication callback. In other words, its replication layout must not be empty.\n\nAll replicated world systems are owned by server. This means that replicated world systems can broadcast information to all clients, but they cannot communicate with specific client (neither sending, nor receiving). We'll talk about communication between specific client and server in section World controllers.\n\nWorld system location\nTo limit world system creation to either server or client, we use Location property of WorldSystemInfo. WorldSystemInfo.SetLocation() takes WorldSystemLocation, which has three possible values: Both, Client and Server. However, game can be running in various multiplayer modes, and mapping might not be obvious. Following table summarizes which multiplayer modes match which locations (yes - system is created, no - system is not created):\n\n\nMultiplayer mode   Both   Client   Server    \n\nSingle-player   yes   yes   yes    \n\nMultiplayer client   yes   yes   no    \n\nMultiplayer listen server   yes   yes   yes    \n\nMultiplayer dedicated server   yes   no   yes   \n\nThis table may look strange at first. After all, why is mode with \"server\" in its name sometimes creating systems with WorldSystemLocation.Client? You might want to think of WorldSystemLocation.Client as \"place where player interacts with the\ngame\" (providing inputs, getting audio-visual output). On the other hand, WorldSystemLocation.Server is \"place where full game simulation happens\" (ie. the only place that knows about everything). In that sense, because there is no way to interact with dedicated server, it makes no sense for world system that should only appear on WorldSystemLocation.Client to be there. On the other hand, a multiplayer client knows only what server told it and doesn't have full picture required for running simulation, so world system that only appears on WorldSystemLocation.Server wouldn't be able to function there. Single-player and listen server (ie. player-hosted server) are basically the same in this regard - they allow player interaction and also know about everything. In fact, single-player is just listen server that doesn't allow clients to connect.\nRemarksLegacy system specifies location using config property \"System Location\" which can be modified in world system config. \n\nWorldSystemLocation enum was previous called ESystemLocation. Old name is still provided as an alias, but it is deprecated and will be removed in the futured.\n\nWorld controllers\nAs mentioned before, world systems are not able to communicate with specific clients. To achieve that, each world system can specify world controllers that should be created along with this system for each player.\nRemarksLegacy world systems do not support world controllers.\nWhile owner of replicated world system is always server, owner of world controller is always one of the players. This allows owner player to communicate with server through the world controller and it also allows server to send information only to particular player via their controller.\nLet's now take a look at an example of a world controller.\nclass PlayerNameInputSystem : WorldSystem // 1.\n{\n    override static void InitInfo(WorldSystemInfo outInfo)\n    {\n        // 2.\n        outInfo\n            .SetAbstract(false)\n            .SetLocation(WorldSystemLocation.Client)\n            .AddPoint(WorldSystemPoint.Frame)\n            .AddController(PlayerNameInputController);\n    }\n \n    override void OnUpdatePoint(WorldUpdatePointArgs args)\n    {\n        string playerName;\n        bool apply = false;\n \n        // Display DbgUI window which allows player to change their name.\n        DbgUI.Begin(\"Player name input\");\n        DbgUI.InputText(\"name\", playerName);\n        apply = DbgUI.Button(\"Apply\");\n        DbgUI.End();\n \n        if (apply)\n        {\n            // 4.\n            auto controller = PlayerNameInputController.Cast(\n                GetSystems().FindMyController(PlayerNameInputController)\n            );\n            controller.RequestNameChange(playerName);\n        }\n    }\n}\n \nclass PlayerNameInputController : WorldController // 1.\n{\n    override static void InitInfo(WorldControllerInfo outInfo)\n    {\n        // 3.\n        outInfo.SetPublic(true);\n    }\n \n    [RplProp(onRplName: \"OnPlayerNameChanged\")]\n    string m_PlayerName;\n \n    void RequestNameChange(string newPlayerName)\n    {\n        Rpc(Rpc_NameChange_S, newPlayerName);\n    }\n \n    [RplRpc(RplChannel.Reliable, RplRcver.Server)]\n    private void Rpc_NameChange_S(string newPlayerName)\n    {\n        if (m_PlayerName == newPlayerName)\n            return;\n \n        m_PlayerName = newPlayerName;\n        Replication.BumpMe();\n        // We invoke callback explicitly on server. On clients, it will be invoked\n        // automatically when replication changes m_PlayerName value.\n        this.OnPlayerNameChanged();\n    }\n \n    private void OnPlayerNameChanged()\n    {\n        PlayerId ownerPlayerId = this.GetOwnerPlayerId();\n        // This message will appear on server and all clients.\n        PrintFormat(\"Player %1 name '%2'\", ownerPlayerId, m_PlayerName);\n    }\n}\n \n\nWe declare our world system called PlayerNameInputSystem, similar to other world systems we've seen before. We also declare PlayerNameInputController which is derived from WorldController. This is how world controllers are declared.\nWe set up WorldSystemInfo. There are two interesting bits here:\nWe set Location to WorldSystemLocation.Client. This system just provides means for player to provide us with some input (player name), so we don't need it on server.\nWe add PlayerNameInputController to WorldSystemInfo property Controllers. This tells the engine which controllers to instantiate for a particular system.\n\n\nWe set up WorldControllerInfo for our controller. This is similar concept as WorldSystemInfo - it gives the engine information about particular controller.\nWhen \"Apply\" button is pressed, we look up PlayerNameInputController instance belonging to player controlling the game and we request change of name through this controller. This request is sent to server where it can be handled.\n\nStep 3. brings up an aspect of controller which wasn't mentioned yet. We said that each controller is owned by particular player. As such, controllers are always streamed to their owners and so each client owning a controller has a proxy instance of it which it can search for (eg. using WorldController.FindMyController()). However, what about controllers belonging to other players? This is what Public property on WorldControllerInfo affects. A public controller is one that appears on all clients, not just its owner. A private controller (ie. one that is not public) will only be present on client who owns it. However, server knows about all controllers (both public and private) and it doesn't matter if it is listen server (which owns one of these controllers) or dedicated server (which doesn't own any controller). So in our example, we take advantage of the fact that controller is public and we use that to communicate name of particular player to all other players.\nYou might also notice how in step 4. we search for controller using WorldController.FindMyController() function. This is similar to World.FindSystem() which we've already seen before. To make inheritance work with this kind of API, WorldControllerInfo also has Unique property, similar to WorldSystemInfo. Behavior of unique controllers is similar to that of unique systems - only one world controller derived from unique world controller type can be instantiated.\nIt may be tempting to use controller constructor to react to controller creation (as a \"player connected\" event of sorts), but you should keep in mind that not everything might be fully set up at the time of constructor invocation. For this purpose, there are other functions on controller which may be better suited for this:\nmodded class PlayerNameInputController\n{\n    override protected void OnAuthorityReady()\n    {\n        Print(\"PlayerNameInputController.OnAuthorityReady()\");\n    }\n \n    private bool RplGiven(ScriptBitReader reader)\n    {\n        Print(\"PlayerNameInputController.RplGiven()\");\n        return true;\n    }\n}\nWorldController.OnAuthorityReady() is part of world controller framework and it is always invoked once authority instance fully prepared. On the other hand, RplGiven() is more general replication callback which is related to ownership transfer in replication, but in this case it can be used as signal that proxy instance on owning client is fully prepared.\nYou might have been wondering why PlayerNameInputController is created both on client and server, even though PlayerNameInputSystem has its Location set to WorldSystemLocation.Client. This is is because world controllers exist purely to allow client-server communication within replication infrastructure. It makes no sense to have client-only or server-only controller. Therefore, when gathering set of world controllers to create based on world systems in config, all world systems which are created either on client or on server have their controller created as well.",
    "filename": "Page_WorldSystems.html"
  }
]